#####################
# StackState values #
#####################
global:
  # global.receiverApiKey -- API key to be used by the Receiver; if no key is provided, a random one will be generated for you.
  receiverApiKey: ""
  # global.imagePullSecrets -- List of image pull secret names to be used by all images across all charts.
  imagePullSecrets: []
  # global.storageClass -- StorageClass for all PVCs created by the chart. Can be overriden per PVC.
  storageClass:
# commonLabels -- Labels that will be added to all resources created by the stackstate chart (not the subcharts though)
commonLabels: {}
backup:
  # backup.additionalLogging -- Additional logback config for backup components
  additionalLogging: ""
  # backup.enabled -- Enables backup/restore, including the MinIO subsystem.
  enabled: false
  elasticsearch:
    # backup.elasticsearch.bucketName -- Name of the MinIO bucket where ElasticSearch snapshots are stored.
    bucketName: 'sts-elasticsearch-backup'
    # backup.elasticsearch.snapshotRepositoryName -- Name of the ElasticSearch snapshot repository.
    snapshotRepositoryName: 'sts-backup'
    restore:
      # backup.elasticsearch.restore.enabled -- Enable ElasticSearch snapshot restore functionality (if `backup.enabled` is set to `true`).
      enabled: true
    scheduled:
      # backup.elasticsearch.scheduled.enabled -- Enable scheduled ElasticSearch snapshots (if `backup.enabled` is set to `true`).
      enabled: true
      # backup.elasticsearch.scheduled.schedule -- Cron schedule for automatic ElasticSearch snaphosts in [ElastichSearch cron schedule syntax](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/cron-expressions.html).
      schedule: '0 0 3 * * ?'
      # backup.elasticsearch.scheduled.indices -- ElasticSearch indices to snapshot in [JSON array format](https://www.w3schools.com/js/js_json_arrays.asp).
      indices: "sts*"
      # backup.elasticsearch.scheduled.snapshotPolicyName -- Name of the ElasticSearch snapshot policy.
      snapshotPolicyName: 'auto-sts-backup'
      # backup.elasticsearch.scheduled.snapshotNameTemplate -- Template for the ElasticSearch snapshot name in [ElasticSearch date math format](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/date-math-index-names.html).
      snapshotNameTemplate: "<sts-backup-{now{yyyyMMdd-HHmm}}>"
      # backup.elasticsearch.scheduled.snapshotRetentionExpireAfter -- Amount of time to keep ElasticSearch snapshots in [ElasticSearch time units](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/common-options.html#time-units). *Note:* By default, the retention task itself [runs daily at 1:30 AM UTC](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/slm-settings.html#slm-retention-schedule).
      snapshotRetentionExpireAfter: "30d"
      # backup.elasticsearch.scheduled.snapshotRetentionMinCount -- Minimum number of ElasticSearch snapshots to keep. *Note:* By default, the retention task itself [runs daily at 1:30 AM UTC](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/slm-settings.html#slm-retention-schedule).
      snapshotRetentionMinCount: "5"
      # backup.elasticsearch.scheduled.snapshotRetentionMaxCount -- Minimum number of ElasticSearch snapshots to keep. *Note:* By default, the retention task itself [runs daily at 1:30 AM UTC](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/slm-settings.html#slm-retention-schedule).
      snapshotRetentionMaxCount: "30"
  poddisruptionbudget:
    # backup.poddisruptionbudget.maxUnavailable -- Maximum number of pods that can be unavailable during the backup.
    maxUnavailable: 0
  stackGraph:
    # backup.stackGraph.bucketName -- Name of the MinIO bucket to store StackGraph backups.
    bucketName: 'sts-stackgraph-backup'
    restore:
      # backup.stackGraph.restore.enabled -- Enable StackGraph backup restore functionality (if `backup.enabled` is set to `true`).
      enabled: true
      tempData:
        # backup.stackGraph.restore.tmpData.accessModes -- Access mode for temporary backup data.
        accessModes: ["ReadWriteOnce"]
        # backup.stackGraph.restore.tmpData.size -- Size of volume for temporary backup data -- must be large enough to store a single backup.
        size: '{{ .Values.hbase.hdfs.datanode.persistence.size }}'
        # backup.stackGraph.restore.tmpData.storageClass -- Storage class of the volume for temporary backup data.
        storageClass:
    scheduled:
      # backup.stackGraph.scheduled.enabled -- Enable scheduled StackGraph backups (if `backup.enabled` is set to `true`).
      enabled: true
      # backup.stackGraph.scheduled.schedule -- Cron schedule for automatic StackGraph backups in [Kubernetes cron schedule syntax](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax).
      schedule: '0 3 * * *'
      # backup.stackGraph.scheduled.backupNameTemplate -- Template for the StackGraph backup name as a double-quoted shell string value.
      backupNameTemplate: 'sts-backup-$(date +%Y%m%d-%H%M).graph'
      # backup.stackGraph.scheduled.backupNameParseRegexp -- Regular expression to retrieve date/time from StackGraph backup name. *Note:* This should match the value for `backupNameTemplate`.
      backupNameParseRegexp: 'sts-backup-([0-9]*-[0-9]*).graph'
      # backup.stackGraph.scheduled.backupDatetimeParseFormat -- Format to parse date/time from StackGraph backup name. *Note:* This should match the value for `backupNameTemplate`.
      backupDatetimeParseFormat: '%Y%m%d-%H%M'
      # backup.stackGraph.scheduled.backupRetentionTimeDelta -- Time to keep StackGraph backups in [Python timedelta format](https://docs.python.org/3/library/datetime.html#timedelta-objects).
      backupRetentionTimeDelta: 'days = 30'
      tempData:
        # backup.stackGraph.scheduled.tmpData.accessModes -- Access mode for temporary backup data.
        accessModes: ["ReadWriteOnce"]
        # backup.stackGraph.scheduled.tmpData.size -- Size of volume for temporary backup data -- must be large enough to store a single backup.
        size: '{{ .Values.hbase.hdfs.datanode.persistence.size }}'
        # backup.stackGraph.scheduled.tmpData.storageClass -- Storage class of the volume for temporary backup data.
        storageClass:
    securityContext:
      # backup.stackGraph.securityContext.enabled -- Whether or not to enable the securityContext
      enabled: true
      # backup.stackGraph.securityContext.fsGroup -- The GID (group ID) of all files on all mounted volumes
      fsGroup: 65534
      # backup.stackGraph.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
      runAsGroup: 65534
      # backup.stackGraph.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
      runAsNonRoot: true
      # backup.stackGraph.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
      runAsUser: 65534
  configuration:
    # backup.configuration.bucketName -- Name of the MinIO bucket to store configuration backups.
    bucketName: 'sts-configuration-backup'
    restore:
      # backup.configuration.restore.enabled -- Enable configuration backup restore functionality (if `backup.enabled` is set to `true`).
      enabled: true
    scheduled:
      # backup.configuration.scheduled.enabled -- Enable scheduled configuration backups (if `backup.enabled` is set to `true`).
      enabled: true
      # backup.configuration.scheduled.schedule -- Cron schedule for automatic configuration backups in [Kubernetes cron schedule syntax](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax).
      schedule: '0 4 * * *'
      # backup.configuration.scheduled.backupNameTemplate -- Template for the configuration backup name as a double-quoted shell string value.
      backupNameTemplate: 'sts-backup-$(date +%Y%m%d-%H%M).stj'
      # backup.configuration.scheduled.backupNameParseRegexp -- Regular expression to retrieve date/time from configuration backup name. *Note:* This should match the value for `backupNameTemplate`.
      backupNameParseRegexp: 'sts-backup-([0-9]*-[0-9]*).stj'
      # backup.configuration.scheduled.backupDatetimeParseFormat -- Format to parse date/time from configuration backup name. *Note:* This should match the value for `backupNameTemplate`.
      backupDatetimeParseFormat: '%Y%m%d-%H%M'
      # backup.configuration.scheduled.backupRetentionTimeDelta -- Time to keep configuration backups in [Python timedelta format](https://docs.python.org/3/library/datetime.html#timedelta-objects).
      backupRetentionTimeDelta: 'days = 365'
    securityContext:
      # backup.configuration.securityContext.enabled -- Whether or not to enable the securityContext
      enabled: true
      # backup.configuration.securityContext.fsGroup -- The GID (group ID) of all files on all mounted volumes
      fsGroup: 65534
      # backup.configuration.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
      runAsGroup: 65534
      # backup.configuration.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
      runAsNonRoot: true
      # backup.configuration.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
      runAsUser: 65534
ingress:
  # ingress.annotations -- Annotations for ingress objects.
  annotations: {}
  # kubernetes.io/ingress.class: nginx
  # kubernetes.io/tls-acme: "true"
  # ingress.enabled -- Enable use of ingress controllers.
  enabled: false
  path: /
  # ingress.hosts -- List of ingress hostnames; the paths are fixed to StackState backend services
  hosts: []
  # - host: stackstate.local
  # ingress.tls -- List of ingress TLS certificates to use.
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - stackstate.local
networkPolicy:
  # networkPolicy.enabled -- Enable creating of `NetworkPolicy` object and associated rules for StackState.
  enabled: false
  # networkPolicy.spec -- `NetworkPolicy` rules for StackState.
  spec:
    ingress:
      - from:
          - podSelector: {}
    podSelector:
      matchLabels: {}
    policyTypes:
      - Ingress
scc:
  # scc.enabled -- Create `SecurityContextConstraints` resource to manage Openshift security constraints for Stackstate.
  # Has to be enabled when installing to Openshift >= 4.12
  # The resource is deployed as a Helm pre-install hook to avoid any warning for the first deployment.
  # Because `helm uninstall` does not consider Helm hooks, the resource must be manually deleted after the Helm release is removed.
  enabled: false
stackstate:
  components:
    all:
      # stackstate.components.all.deploymentStrategy.type -- Deployment strategy for StackState components. Possible values: `RollingUpdate`, `Recreate` and `RecreateSingletonsOnly`.
      # `RecreateSingletonsOnly` uses `Recreate` for the singleton Deployments and `RollingUpdate` for the other Deployments.
      deploymentStrategy:
        type: RecreateSingletonsOnly
      extraEnv:
        # stackstate.components.all.extraEnv.open -- Extra open environment variables to inject into pods for all components.
        open: {}
        # stackstate.components.all.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object for all components.
        secret: {}
      image:
        # stackstate.components.all.image.registry -- Base container image registry for all StackState containers, except for the wait container and the container-tools container
        registry: quay.io
        # stackstate.components.all.image.repositorySuffix - String to append to repositories for StackState components
        repositorySuffix: ""
        # stackstate.components.all.image.pullSecretName -- Name of ImagePullSecret to use for all pods.
        pullSecretName:
        # all.image.pullSecretUsername -- Username used to login to the registry to pull Docker images of all pods.
        pullSecretUsername:
        # all.image.pullSecretPassword -- Password used to login to the registry to pull Docker images of all pods.
        pullSecretPassword:
        # stackstate.components.all.image.pullPolicy -- The default pullPolicy used for all stateless components of StackState; invividual service `pullPolicy`s can be overriden (see below).
        pullPolicy: IfNotPresent
        # When changing this value make sure to also update hbase.stackgraph.image.tag to the matching StackGraph version
        # stackstate.components.all.image.tag -- The default tag used for all stateless components of StackState; invividual service `tag`s can be overriden (see below).
        tag: 6.0.0-snapshot.20231220164023-master-9c34a80
      metrics:
        defaultAgentMetricsFilter: '["kafka_consumer_consumer_fetch_manager_metrics*", "kafka_producer_producer_topic_metrics*", "jvm*", "akka_http_requests_active", "stackstate*", "receiver*", "stackgraph*"]'
        # stackstate.components.all.metrics.enabled -- Enable metrics port.
        enabled: true
        # stackstate.components.all.metrics.agentAnnotationsEnabled -- Put annotations on each pod to instruct the stackstate agent to scrape the metrics
        agentAnnotationsEnabled: true
        servicemonitor:
          # stackstate.components.all.metrics.servicemonitor.additionalLabels -- Additional labels for targeting Prometheus operator instances.
          additionalLabels: {}
          # stackstate.components.all.metrics.servicemonitor.enabled -- Enable `ServiceMonitor` object; `all.metrics.enabled` *must* be enabled.
          enabled: false
      securityContext:
        # stackstate.components.all.securityContext.enabled -- Whether or not to enable the securityContext
        enabled: true
        # stackstate.components.all.securityContext.fsGroup -- The GID (group ID) used to mount volumes
        fsGroup: 65534
        # stackstate.components.all.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
        runAsGroup: 65534
        # stackstate.components.all.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
        runAsNonRoot: true
        # stackstate.components.all.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
        runAsUser: 65534
      # stackstate.components.all.elasticsearchEndpoint -- **Required if `elasticsearch.enabled` is `false`** Endpoint for shared Elasticsearch cluster.
      elasticsearchEndpoint: ""
      metricStore:
        # stackstate.components.all.metricStore.remoteWriteEndpoint -- Host and port for prometheus remote write endpoint ($vmInstance is replaced by '0' or '1')
        remoteWriteEndpoint: "stackstate-victoria-metrics-$vmInstance:8428"
        # stackstate.components.all.metricStore.remoteWritePath -- Remote write path used to ingest metrics, /api/v1/write is most common
        remoteWritePath: "/api/v1/write"
        # stackstate.components.all.metricStore.queryApiEndpoint -- Host and port for promql api
        queryApiEndpoint: "stackstate-victoriametrics:8428"
        # stackstate.components.all.metricStore.queryApiPath -- Path under which `/api/v1/query` etc.. are accessible, the default ("") is fine for most stores
        queryApiPath: ""
      # stackstate.components.all.kafkaEndpoint -- **Required if `elasticsearch.enabled` is `false`** Endpoint for shared Kafka broker.
      kafkaEndpoint: ""
      # stackstate.components.all.zookeeperEndpoint -- **Required if `zookeeper.enabled` is `false`** Endpoint for shared Zookeeper nodes.
      zookeeperEndpoint: ""
      # stackstate.components.all.nodeSelector -- Node labels for pod assignment on all components.
      nodeSelector: {}
      # stackstate.components.all.tolerations -- Toleration labels for pod assignment on all components.
      tolerations: []
      # stackstate.components.all.affinity -- Affinity settings for pod assignment on all components.
      affinity: {}
    api:
      extraEnv:
        # stackstate.components.api.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.api.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.api.image.imageRegistry -- `imageRegistry` used for the `api` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.api.image.pullPolicy -- `pullPolicy` used for the `api` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.api.image.repository -- Repository of the api component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.api.image.tag -- Tag used for the `api` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.api.poddisruptionbudget -- PodDisruptionBudget settings for `api` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.api.resources -- Resource allocation for `api` pods.
      resources:
        limits:
          memory: "2Gi"
          cpu: "2000m"
          ephemeral-storage: "2Gi"
        requests:
          memory: "2Gi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "50"
      # stackstate.components.api.replicaCount -- Number of `api` replicas.
      replicaCount: 1
      # stackstate.components.api.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.api.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.api.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.api.config -- Configuration file contents to customize the default StackState api configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.api.additionalLogging -- Additional logback config
      additionalLogging: ""
      # stackstate.components.api.docslink -- Documentation URL root to use in the product help page & tooltips.
      docslink: ""
    backup:
      resources:
        limits:
          memory: "4000Mi"
          cpu: "3000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "4000Mi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
    correlate:
      extraEnv:
        # stackstate.components.correlate.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.correlate.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.correlate.image.imageRegistry -- `imageRegistry` used for the `correlate` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.correlate.image.pullPolicy -- `pullPolicy` used for the `correlate` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.correlate.image.repository -- Repository of the correlate component Docker image.
        repository: stackstate/stackstate-correlate
        # stackstate.components.correlate.image.tag -- Tag used for the `correlate` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.correlate.poddisruptionbudget -- PodDisruptionBudget settings for `correlate` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.correlate.resources -- Resource allocation for `correlate` pods.
      resources:
        limits:
          memory: "2800Mi"
          cpu: "2000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "2800Mi"
          cpu: "600m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "400Mi"
        javaHeapMemoryFraction: "65"
      # stackstate.components.correlate.replicaCount -- Number of `correlate` replicas.
      replicaCount: 1
      # stackstate.components.correlate.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.correlate.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.correlate.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.correlate.additionalLogging -- Additional logback config
      additionalLogging: ""
    checks:
      extraEnv:
        # stackstate.components.checks.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.checks.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.checks.image.imageRegistry -- `imageRegistry` used for the `checks` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.checks.image.pullPolicy -- `pullPolicy` used for the `state` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.checks.image.repository -- Repository of the sync component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.checks.image.tag -- Tag used for the `state` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.checks.poddisruptionbudget -- PodDisruptionBudget settings for `checks` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.checks.resources -- Resource allocation for `state` pods.
      resources:
        limits:
          memory: "4000Mi"
          cpu: "2000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "4000Mi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "60"
      # stackstate.components.checks.replicaCount -- Number of `checks` replicas.
      replicaCount: 1
      # stackstate.components.checks.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.checks.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.checks.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.checks.config -- Configuration file contents to customize the default StackState state configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.checks.additionalLogging -- Additional logback config
      additionalLogging: ""
      # stackstate.components.checks.tmpToPVC -- Whether to use PersistentVolume to store temporary files (/tmp) instead of pod ephemeral storage, empty - use pod ephemeral storage.
      tmpToPVC:
        # stackstate.components.checks.tmpToPVC.volumeSize -- (string) The size of the PersistentVolume for "/tmp" directory.
        volumeSize: 2Gi
        # stackstate.components.checks.tmpToPVC.storageClass -- (string) Storage class name of PersistentVolume used by /tmp directory. It stores temporary files/caches, so it should be the fastest possible.
        storageClass: null
    healthSync:
      extraEnv:
        # stackstate.components.healthSync.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.healthSync.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.healthSync.image.imageRegistry -- `imageRegistry` used for the `healthSync` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.healthSync.image.pullPolicy -- `pullPolicy` used for the `healthSync` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.healthSync.image.repository -- Repository of the healthSync component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.healthSync.image.tag -- Tag used for the `healthSync` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.healthSync.poddisruptionbudget -- PodDisruptionBudget settings for `healthSync` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.healthSync.resources -- Resource allocation for `healthSync` pods.
      resources:
        limits:
          memory: "3500Mi"
          cpu: "1500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "3500Mi"
          cpu: "400m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "450Mi"
        javaHeapMemoryFraction: "45"
      # stackstate.components.healthSync.replicaCount -- Number of `healthSync` replicas.
      replicaCount: 1
      # stackstate.components.healthSync.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.healthSync.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.healthSync.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.healthSync.config -- Configuration file contents to customize the default StackState healthSync configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.healthSync.additionalLogging -- Additional logback config
      additionalLogging: ""
      cache:
        # stackstate.components.healthSync.cache.backend -- Type of cache backend used by the service, possible values are mapdb, rocksdb and inmemory
        backend: "mapdb"
      # stackstate.components.healthSync.tmpToPVC -- Whether to use PersistentVolume to store temporary files (/tmp) instead of pod ephemeral storage, empty - use pod ephemeral storage.
      tmpToPVC:
        # stackstate.components.healthSync.tmpToPVC.volumeSize -- (string) The size of the PersistentVolume for "/tmp" directory.
        volumeSize: 2Gi
        # stackstate.components.healthSync.tmpToPVC.storageClass -- (string) Storage class name of PersistentVolume used by /tmp directory. It stores temporary files/caches, so it should be the fastest possible.
        storageClass: null
    initializer:
      extraEnv:
        # stackstate.components.initializer.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.initializer.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.initializer.image.imageRegistry -- `imageRegistry` used for the `initializer` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.initializer.image.pullPolicy -- `pullPolicy` used for the `initializer` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.initializer.image.repository -- Repository of the initializer component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.initializer.image.tag -- Tag used for the `initializer` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.initializer.resources -- Resource allocation for `initializer` pods.
      resources:
        limits:
          memory: "1500Mi"
          cpu: "1500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "512Mi"
          cpu: "250m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "350Mi"
        javaHeapMemoryFraction: "65"
      # stackstate.components.initializer.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.initializer.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.initializer.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.initializer.config -- Configuration file contents to customize the default StackState initializer configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.initializer.additionalLogging -- Additional logback config
      additionalLogging: ""
    e2es:
      extraEnv:
        # stackstate.components.e2es.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.e2es.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.e2es.image.pullPolicy -- `pullPolicy` used for the `e2es` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.e2es.image.repository -- Repository of the e2es component Docker image.
        repository: stackstate/stackstate-kafka-to-es
        # stackstate.components.e2es.image.tag -- Tag used for the `e2es` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.e2es.poddisruptionbudget -- PodDisruptionBudget settings for `e2es` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.e2es.resources -- Resource allocation for `e2es` pods.
      resources:
        limits:
          memory: "1500Mi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "768Mi"
          cpu: "250m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "300Mi"
        javaHeapMemoryFraction: "50"
      # stackstate.components.e2es.replicaCount -- Number of `e2es` replicas.
      replicaCount: 1
      # stackstate.components.e2es.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.e2es.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.e2es.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.e2es.additionalLogging -- Additional logback config
      additionalLogging: ""
      # stackstate.components.e2es.esDiskSpaceShare -- How much disk space from ElasticSearch can use for k8s events ingestion
      esDiskSpaceShare: "30"
      # stackstate.components.e2es.retention -- Number of days to keep the events data on Es
      retention: 30
    trace2es:
      extraEnv:
        # stackstate.components.trace2es.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.trace2es.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.trace2es.image.pullPolicy -- `pullPolicy` used for the `trace2es` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.trace2es.image.repository -- Repository of the trace2es component Docker image.
        repository: stackstate/stackstate-kafka-to-es
        # stackstate.components.trace2es.image.tag -- Tag used for the `trace2es` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.trace2es.poddisruptionbudget -- PodDisruptionBudget settings for `trace2es` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.trace2es.resources -- Resource allocation for `trace2es` pods.
      resources:
        limits:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "300Mi"
        javaHeapMemoryFraction: "50"
      # stackstate.components.trace2es.replicaCount -- Number of `trace2es` replicas.
      replicaCount: 1
      # stackstate.components.trace2es.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.trace2es.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.trace2es.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.trace2es.enabled -- Enable/disable the trace2es service
      enabled: false
      # stackstate.components.trace2es.additionalLogging -- Additional logback config
      additionalLogging: ""
      # stackstate.components.trace2es.esDiskSpaceShare -- How much disk space from ElasticSearch can use for k8s events ingestion
      esDiskSpaceShare: "0"
      # stackstate.components.trace2es.retention -- Number of days to keep the traces data on Es
      retention: 7
    notification:
      extraEnv:
        # stackstate.components.notification.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.notification.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.notification.image.imageRegistry -- `imageRegistry` used for the `notification` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.notification.image.pullPolicy -- `pullPolicy` used for the `notification` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.notification.image.repository -- Repository of the notification component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.notification.image.tag -- Tag used for the `notification` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.notification.poddisruptionbudget -- PodDisruptionBudget settings for `notification` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.notification.resources -- Resource allocation for `notification` pods.
      resources:
        limits:
          memory: "1500Mi"
          cpu: "750m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1500Mi"
          cpu: "250m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "350Mi"
        javaHeapMemoryFraction: "60"
      # stackstate.components.notification.replicaCount -- Number of `notification` replicas.
      replicaCount: 1
      # stackstate.components.notification.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.notification.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.notification.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.notification.config -- Configuration file contents to customize the default StackState notification configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.notification.additionalLogging -- Additional logback config
      additionalLogging: ""
      # stackstate.components.notification.tmpToPVC -- Whether to use PersistentVolume to store temporary files (/tmp) instead of pod ephemeral storage, empty - use pod ephemeral storage.
    receiver:
      extraEnv:
        # stackstate.components.receiver.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.receiver.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.receiver.image.imageRegistry -- `imageRegistry` used for the `receiver` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.receiver.image.pullPolicy -- `pullPolicy` used for the `receiver` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.receiver.image.repository -- Repository of the receiver component Docker image.
        repository: stackstate/stackstate-receiver
        # stackstate.components.receiver.image.tag -- Tag used for the `receiver` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.receiver.poddisruptionbudget -- PodDisruptionBudget settings for `receiver` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.receiver.resources -- Resource allocation for `receiver` pods.
      resources:
        limits:
          memory: "4Gi"
          cpu: "3000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "4Gi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "300Mi"
        javaHeapMemoryFraction: "65"
      # stackstate.components.receiver.replicaCount -- Number of `receiver` replicas.
      replicaCount: 1
      # stackstate.components.receiver.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.receiver.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.receiver.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.receiver.additionalLogging -- Additional logback config
      additionalLogging: ""
      # stackstate.components.receiver.esDiskSpaceShare -- How much disk space from ElasticSearch can use for k8s log ingestion
      esDiskSpaceShare: "70"
      # stackstate.components.receiver.retention -- Number of days to keep the logs data on Es
      retention: 7
    router:
      accesslog:
        # stackstate.components.router.accesslog.enabled -- Enable access logging on the router
        enabled: false
      extraEnv:
        # stackstate.components.router.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.router.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.router.image.pullPolicy -- `pullPolicy` used for the `router` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.router.image.registry -- Registry of the router component Docker image.
        registry: quay.io
        # stackstate.components.router.image.repository -- Repository of the router component Docker image.
        repository: stackstate/envoy
        # stackstate.components.router.image.tag -- Tag used for the `router` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: v1.19.1-e418b2bd
      # stackstate.components.router.poddisruptionbudget -- PodDisruptionBudget settings for `router` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.router.resources -- Resource allocation for `router` pods.
      resources:
        limits:
          cpu: "100m"
          memory: "128Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "100m"
          memory: "128Mi"
          ephemeral-storage: "1Mi"
      # stackstate.components.router.replicaCount -- Number of `router` replicas.
      replicaCount: 1
      # stackstate.components.router.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.router.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.router.affinity -- Affinity settings for pod assignment.
      affinity: {}
    server:
      extraEnv:
        # stackstate.components.server.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.server.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.server.image.imageRegistry -- `imageRegistry` used for the `server` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.server.image.pullPolicy -- `pullPolicy` used for the `server` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.server.image.repository -- Repository of the server component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.server.image.tag -- Tag used for the `server` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.server.poddisruptionbudget -- PodDisruptionBudget settings for `server` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.server.resources -- Resource allocation for `server` pods.
      resources:
        limits:
          memory: "8Gi"
          cpu: "3600m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "8Gi"
          cpu: "3600m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "70"
      # stackstate.components.server.replicaCount -- Number of `server` replicas.
      replicaCount: 1
      # stackstate.components.server.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.server.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.server.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.server.config -- Configuration file contents to customize the default StackState configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.server.additionalLogging -- Additional logback config
      additionalLogging: ""
    state:
      extraEnv:
        # stackstate.components.state.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.state.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.state.image.imageRegistry -- `imageRegistry` used for the `state` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.state.image.pullPolicy -- `pullPolicy` used for the `state` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.state.image.repository -- Repository of the sync component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.state.image.tag -- Tag used for the `state` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.state.poddisruptionbudget -- PodDisruptionBudget settings for `state` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.state.resources -- Resource allocation for `state` pods.
      resources:
        limits:
          cpu: "1000m"
          memory: "2000Mi"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1536Mi"
          cpu: "500m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "300Mi"
        javaHeapMemoryFraction: "70"
      # stackstate.components.state.replicaCount -- Number of `state` replicas.
      replicaCount: 1
      # stackstate.components.state.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.state.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.state.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.state.config -- Configuration file contents to customize the default StackState state configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.state.additionalLogging -- Additional logback config
      additionalLogging: ""
      # stackstate.components.state.tmpToPVC -- Whether to use PersistentVolume to store temporary files (/tmp) instead of pod ephemeral storage, empty - use pod ephemeral storage.
      tmpToPVC:
        # stackstate.components.state.tmpToPVC.volumeSize -- (string) The size of the PersistentVolume for "/tmp" directory.
        volumeSize: 2Gi
        # stackstate.components.state.tmpToPVC.storageClass -- (string) Storage class name of PersistentVolume used by /tmp directory. It stores temporary files/caches, so it should be the fastest possible.
        storageClass: null
    sync:
      extraEnv:
        # stackstate.components.sync.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.sync.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.sync.image.imageRegistry -- `imageRegistry` used for the `sync` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.sync.image.pullPolicy -- `pullPolicy` used for the `sync` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.sync.image.repository -- Repository of the sync component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.sync.image.tag -- Tag used for the `sync` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.sync.poddisruptionbudget -- PodDisruptionBudget settings for `sync` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.sync.resources -- Resource allocation for `sync` pods.
      resources:
        limits:
          memory: "4Gi"
          cpu: "3000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "3Gi"
          cpu: "750m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "400Mi"
        javaHeapMemoryFraction: "60"
      # stackstate.components.sync.replicaCount -- Number of `sync` replicas.
      replicaCount: 1
      # stackstate.components.sync.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.sync.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.sync.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.sync.config -- Configuration file contents to customize the default StackState sync configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.sync.additionalLogging -- Additional logback config
      additionalLogging: ""
      cache:
        # stackstate.components.sync.cache.backend -- Type of cache backend used by the service, possible values are mapdb, rocksdb and inmemory
        backend: "mapdb"
      # stackstate.components.sync.tmpToPVC -- Whether to use PersistentVolume to store temporary files (/tmp) instead of pod ephemeral storage, empty - use pod ephemeral storage.
      tmpToPVC:
        # stackstate.components.sync.tmpToPVC.volumeSize -- (string) The size of the PersistentVolume for "/tmp" directory.
        volumeSize: 2Gi
        # stackstate.components.sync.tmpToPVC.storageClass -- (string) Storage class name of PersistentVolume used by /tmp directory. It stores temporary files/caches, so it should be the fastest possible.
        storageClass: null
    slicing:
      extraEnv:
        # stackstate.components.slicing.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.slicing.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.slicing.image.imageRegistry -- `imageRegistry` used for the `slicing` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.slicing.image.pullPolicy -- `pullPolicy` used for the `slicing` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.slicing.image.repository -- Repository of the slicing component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.slicing.image.tag -- Tag used for the `slicing` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.slicing.resources -- Resource allocation for `slicing` pods.
      resources:
        limits:
          cpu: "1500m"
          memory: "1800Mi"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1536Mi"
          cpu: "250m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "60"
      # stackstate.components.slicing.replicaCount -- Number of `slicing` replicas.
      replicaCount: 1
      # stackstate.components.slicing.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.slicing.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.slicing.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.slicing.config -- Configuration file contents to customize the default StackState slicing configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.slicing.additionalLogging -- Additional logback config
      additionalLogging: ""
    ui:
      agentMetricsFilter: '["nginx*"]'
      debug: false
      extraEnv:
        # stackstate.components.ui.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.ui.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.ui.image.imageRegistry -- `imageRegistry` used for the `ui` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.ui.image.pullPolicy -- `pullPolicy` used for the `ui` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.ui.image.repository -- Repository of the ui component Docker image.
        repository: stackstate/stackstate-ui
        # stackstate.components.ui.image.tag -- Tag used for the `ui` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.ui.poddisruptionbudget -- PodDisruptionBudget settings for `ui` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.ui.resources -- Resource allocation for `ui` pods.
      resources:
        limits:
          cpu: "50m"
          memory: "64Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "50m"
          memory: "64Mi"
          ephemeral-storage: "1Mi"
      securityContext:
        # stackstate.components.ui.securityContext.enabled -- Whether or not to enable the securityContext
        enabled: true
        # stackstate.components.ui.securityContext.fsGroup -- The GID (group ID) used to mount volumes
        fsGroup: 101
        # stackstate.components.ui.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
        runAsGroup: 101
        # stackstate.components.ui.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
        runAsNonRoot: true
        # stackstate.components.ui.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
        runAsUser: 101
      # stackstate.components.ui.replicaCount -- Number of `ui` replicas.
      replicaCount: 2
      # stackstate.components.ui.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.ui.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.ui.affinity -- Affinity settings for pod assignment.
      affinity: {}
    viewHealth:
      extraEnv:
        # stackstate.components.viewHealth.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.viewHealth.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.viewHealth.image.imageRegistry -- `imageRegistry` used for the `viewHealth` component Docker image; this will override `global.imageRegistry` on a per-service basis.
        imageRegistry: ""
        # stackstate.components.viewHealth.image.pullPolicy -- `pullPolicy` used for the `viewHealth` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.viewHealth.image.repository -- Repository of the viewHealth component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.viewHealth.image.tag -- Tag used for the `viewHealth` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.viewHealth.poddisruptionbudget -- PodDisruptionBudget settings for `viewHealth` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.viewHealth.resources -- Resource allocation for `viewHealth` pods.
      resources:
        limits:
          memory: "2700Mi"
          cpu: "2000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "2Gi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "400Mi"
        javaHeapMemoryFraction: "55"
      # stackstate.components.viewHealth.replicaCount -- Number of `viewHealth` replicas.
      replicaCount: 1
      # stackstate.components.viewHealth.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.viewHealth.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.viewHealth.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.viewHealth.config -- Configuration file contents to customize the default StackState viewHealth configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.viewHealth.additionalLogging -- Additional logback config
      additionalLogging: ""
    kafkaTopicCreate:
      image:
        # stackstate.components.kafkaTopicCreate.image.registry -- Base container image registry for kafka-topic-create containers.
        registry: quay.io
        # stackstate.components.kafkaTopicCreate.image.repository -- Base container image repository for kafka-topic-create containers.
        repository: stackstate/kafka
        # stackstate.components.kafkaTopicCreate.image.tag -- Container image tag for kafka-topic-create containers.
        tag: 3.3.1-08305c25
        # stackstate.components.kafkaTopicCreate.image.pullPolicy -- Image pull policy for kafka-topic-create containers.
        pullPolicy: IfNotPresent
      # stackstate.components.kafkaTopicCreate.resources -- Resource allocation for `kafkaTopicCreate` pods.
      resources:
        limits:
          cpu: "1000m"
          memory: "2000Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "500m"
          memory: "2000Mi"
          ephemeral-storage: "1Mi"
      securityContext:
        # stackstate.components.kafkaTopicCreate.securityContext.enabled -- Whether or not to enable the securityContext
        enabled: true
        # stackstate.components.kafkaTopicCreate.securityContext.fsGroup -- The GID (group ID) used to mount volumes
        fsGroup: 1001
        # stackstate.components.kafkaTopicCreate.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
        runAsGroup: 1001
        # stackstate.components.kafkaTopicCreate.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
        runAsNonRoot: true
        # stackstate.components.kafkaTopicCreate.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
        runAsUser: 1001
      # stackstate.components.kafkaTopicCreate.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.kafkaTopicCreate.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.kafkaTopicCreate.affinity -- Affinity settings for pod assignment.
      affinity: {}
    nginxPrometheusExporter:
      image:
        # stackstate.components.nginxPrometheusExporter.image.registry -- Base container image registry for nginx-prometheus-exporter containers.
        registry: quay.io
        # stackstate.components.nginxPrometheusExporter.image.repository -- Base container image repository for nginx-prometheus-exporter containers.
        repository: stackstate/nginx-prometheus-exporter
        # stackstate.components.nginxPrometheusExporter.image.tag -- Container image tag for nginx-prometheus-exporter containers.
        tag: 0.9.0-2738682730
        # stackstate.components.nginxPrometheusExporter.image.pullPolicy -- Image pull policy for nginx-prometheus-exporter containers.
        pullPolicy: IfNotPresent
    containerTools:
      image:
        # stackstate.components.containerTools.image.registry -- Base container image registry for container-tools containers.
        registry: quay.io
        # stackstate.components.containerTools.image.repository -- Base container image repository for container-tools containers.
        repository: stackstate/container-tools
        # stackstate.components.containerTools.image.tag -- Container image tag for container-tools containers.
        tag: 1.2.0
        # stackstate.components.containerTools.image.pullPolicy -- Image pull policy for container-tools containers.
        pullPolicy: IfNotPresent
      # stackstate.components.containerTools.resources -- Resource allocation for `kafkaTopicCreate` pods.
      resources:
        limits:
          cpu: "1000m"
          memory: "2000Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "500m"
          memory: "2000Mi"
          ephemeral-storage: "1Mi"
    vmagent:
      image:
        repository: stackstate/vmagent
        tag: v1.93.7-37ef8c51
      # stackstate.components.vmagent.poddisruptionbudget -- PodDisruptionBudget settings for `vmagent` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      extraArgs: {}
      persistence:
        size: 10Gi
        storageClass:
      # stackstate.components.vmagent.resources -- Resource allocation for vmagent pod.
      resources:
        limits:
          cpu: "200m"
          memory: "512Mi"
          ephemeral-storage: "100Mi"
        requests:
          cpu: "200m"
          memory: "256Mi"
          ephemeral-storage: "1Mi"
      # stackstate.components.vmagent.affinity -- Affinity settings for vmagent pod.
      affinity:
        podAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 80
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app.kubernetes.io/component
                      operator: In
                      values:
                        - receiver
                    - key: app.kubernetes.io/instance
                      operator: In
                      values:
                        - stackstate
                topologyKey: kubernetes.io/hostname
      agentMetricsFilter: '["vmagent*"]'
    wait:
      image:
        # stackstate.components.wait.image.registry -- Base container image registry for wait containers.
        registry: quay.io
        # stackstate.components.wait.image.repository -- Base container image repository for wait containers.
        repository: stackstate/wait
        # stackstate.components.wait.image.tag -- Container image tag for wait containers.
        tag: 1.0.9-b6a3cb01
        # stackstate.components.wait.image.pullPolicy -- Image pull policy for wait containers.
        pullPolicy: IfNotPresent
  # stackstate.authentication -- Configure the authentication settings for StackState here. Only one of the authentication providers can be used, configuring multiple will result in an error.
  authentication:
    # stackstate.authentication.keycloak -- Use Keycloak as authentication provider. See [Configuring Keycloak](#configuring-keycloak).
    keycloak: {}
    # stackstate.authentication.ldap -- LDAP settings for StackState. See [Configuring LDAP](#configuring-ldap).
    ldap: {}
    # stackstate.authentication.oidc -- Use an OpenId Connect provider for authentication. See [Configuring OpenId Connect](#configuring-openid-connect).
    oidc: {}
    # stackstate.authentication.file -- Configure users, their passwords and roles from (config) file
    file: {}
    # stackstate.authentication.adminPassword -- Password for the 'admin' user that StackState creates by default
    adminPassword:
    # stackstate.authentication.sessionLifetime -- Amount of time to keep a session when a user does not log in
    sessionLifetime: 7d
    # stackstate.authentication.roles -- Extend the default role names in StackState
    roles:
      # stackstate.authentication.roles.admin -- Extend the role names that have admin permissions (default: 'stackstate-admin')
      admin: []
      # stackstate.authentication.roles.platformAdmin -- Extend the role names that have platform admin permissions (default: 'stackstate-platform-admin')
      platformAdmin: []
      # stackstate.authentication.roles.powerUser -- Extend the role names that have power user permissions (default: 'stackstate-power-user')
      powerUser: []
      # stackstate.authentication.roles.guest -- Extend the role names that have guest permissions (default: 'stackstate-guest')
      guest: []
      # stackstate.authentication.roles.k8sTroubleshooter -- Extend the role names that have troubleshooter permissions (default: 'stackstate-k8s-troubleshooter')
      k8sTroubleshooter: []
      # stackstate.authentication.roles.custom -- Extend the authorization with custom roles {roleName: {systemPermissions: [], viewPermissions: [], topologyScope: ""}}
      custom: {}
    serviceToken:
      bootstrap:
        # stackstate.authentication.serviceToken.bootstrap.token -- The service token to set as bootstrap token
        token: ""
        # stackstate.authentication.serviceToken.bootstrap.roles -- The roles the service token assumes when its used for authentication
        roles: []
        # stackstate.authentication.serviceToken.bootstrap.ttl -- The amount of time the service token is valid for
        ttl: 24h
  admin:
    authentication:
      # stackstate.admin.authentication.password -- Password used for default platform "admin" api's (low-level tools) of the various services, username: platformadmin
      password:
  instanceApi:
    # stackstate.instanceApi.authentication -- Custom authentication settings for the `instance` API, by default the `stackstate.authentication` authentication settings are used.
    authentication: {}
  # stackstate.deployment -- Deployment settings for StackState
  deployment:
    # stackstate.deployment.mode -- Deployment mode of StackState, possible values are 'SaaS' and 'SelfHosted'
    mode: "SelfHosted"
  # stackstate.java -- Extra Java configuration for StackState
  java:
    # stackstate.java.trustStore -- Java TrustStore (cacerts) file to use
    trustStore:
    # stackstate.java.trustStoreBase64Encoded -- Base64 encoded Java TrustStore (cacerts) file to use. Ignored if stackstate.java.trustStore is set.
    trustStoreBase64Encoded:
    # stackstate.java.trustStorePassword -- Password to access the Java TrustStore (cacerts) file
    trustStorePassword:
  license:
    # stackstate.license.key -- (string) **PROVIDE YOUR LICENSE KEY HERE** The StackState license key needed to start the server.
    key:
  # stackstate.web.baseUrl -- (string) **PROVIDE YOUR BASE URL HERE** Externally visible baseUrl of StackState.
  baseUrl:
  receiver:
    # stackstate.receiver.baseUrl -- (string) **DEPRECATED** Use stackstate.baseUrl instead
    baseUrl:
  experimental:
    enableVMAgent: true
    server:
      # stackstate.experimental.server.split -- (boolean) Run a single service server or split in multiple sub services as api, state ....
      split: true
    storeTransactionLogsToPVC:
      # stackstate.experimental.storeTransactionLogsToPVC.enabled -- (boolean) Whether the transcation logs for some services, API, Checks, HealthSync,State, Sync, and ViewHealth, have to be stored to PVCs instead of pod ephemeral storage.
      enabled: false
      # stackstate.experimental.storeTransactionLogsToPVC.volumeSize -- (string) The size of the persistent volume for the transaction logs.
      volumeSize: 600Mi
      # stackstate.experimental.storeTransactionLogsToPVC.storageClass -- (string) Storage class name of PersistentVolume used by transaction logs.
      storageClass:
  stackpacks:
    # stackstate.stackpacks.installed -- Specify a list of stackpacks to be always installed including their configuration, for an example see [Auto-installing StackPacks](#auto-installing-stackpacks)
    installed: []
    # stackstate.stackpacks.upgradeOnStartup -- Specify a list of stackpacks that will, on startup only, be upgraded to the latest version available
    upgradeOnStartup: []
    # stackstate.stackpacks.source -- Source of the stackpacks. Can be either 'docker-image' or 's3-bucket'.
    source: "docker-image"
    updateInterval: "5 minutes"
    # stackstate.stackpacks.pvcSize -- Size of the Persistent Volume Claim (PVC) used to copy stackpacks from the Docker image.
    pvc:
      size: 1Gi
      storageClass:
    image:
      # stackstate.stackpacks.image.registry -- `registry` used for the `stackpacks` Docker image; this will override `global.imageRegistry` on a per-service basis.
      registry: "quay.io"
      # stackstate.stackpacks.image.pullPolicy -- `pullPolicy` used for the `stackpacks` Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
      pullPolicy: ""
      # stackstate.stackpacks.image.repository -- Repository of the `stackpacks` Docker image.
      repository: stackstate/stackpacks
      # stackstate.stackpacks.image.tag -- Tag used for the `stackpacks` Docker image;
      tag: "20231221123148-master-9f98c85-selfhosted"
    s3:
      # stackstate.stackpacks.s3.bucket -- Name of the S3 bucket to use as source for stackpacks.
      bucket: "sts-stackpacks-prod"
      # stackstate.stackpacks.s3.accesskey -- Access key for the S3 bucket to use as source for stackpacks.
      accesskey: ""
      # stackstate.stackpacks.s3.secretkey -- Secret key for the S3 bucket to use as source for stackpacks.
      secretkey: ""
      # stackstate.stackpacks.s3.region -- Region of the S3 bucket to use as source for stackpacks.
      region: "eu-west-1"
      # stackstate.stackpacks.s3.endpoint -- AWS S3 Endpoint to use, can be used to point to a local S3 compatible storage.
      endpoint:
##############################
# Dependency chart overrides #
##############################
elasticsearch:
  # elasticsearch.clusterHealthCheckParams -- The Elasticsearch cluster health status params that will be used by readinessProbe command
  clusterHealthCheckParams: "wait_for_status=yellow&timeout=1s"
  # elasticsearch.clusterName -- Name override for Elasticsearch child chart. **Don't change unless otherwise specified; this is a Helm v2 limitation, and will be addressed in a later Helm v3 chart.**
  clusterName: stackstate-elasticsearch
  # elasticsearch.enabled -- Enable / disable chart-based Elasticsearch.
  enabled: true
  # elasticsearch.esJavaOpts -- JVM options
  esJavaOpts: "-Xmx3g -Xms3g -Des.allow_insecure_settings=true -Xlog:disable -Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=8,filesize=16m"
  # elasticsearch.commonLabels -- Add additional labels to all resources created for elasticsearch
  commonLabels:
    app.kubernetes.io/part-of: stackstate-k8s
  # elasticsearch.extraEnvs -- Extra settings that StackState uses for Elasticsearch.
  extraEnvs:
    - name: action.auto_create_index
      value: "true"
    - name: indices.query.bool.max_clause_count
      value: "10000"
  # elasticsearch.minimumMasterNodes -- Minimum number of Elasticsearch master nodes.
  minimumMasterNodes: 2
  nodeGroup: "master"
  # elasticsearch.replicas -- Number of Elasticsearch replicas.
  replicas: 3
  # elasticsearch.resources -- Override Elasticsearch resources
  resources:
    requests:
      cpu: "1000m"
      memory: "4Gi"
      ephemeral-storage: "1Mi"
    limits:
      cpu: "2000m"
      memory: "4Gi"
      ephemeral-storage: "1Gi"
  # elasticsearch.volumeClaimTemplate -- PVC template defaulting to 250Gi default volumes
  volumeClaimTemplate:
    accessModes:
      - "ReadWriteOnce"
    resources:
      requests:
        storage: 250Gi
  prometheus-elasticsearch-exporter:
    enabled: true
    serviceMonitor:
      enabled: false
      # elasticsearch.prometheus-elasticsearch-exporter.serviceMonitor.labels -- Labels for the service monitor
      labels: {}
    podAnnotations:
      ad.stackstate.com/exporter.check_names: '["openmetrics"]'
      ad.stackstate.com/exporter.init_configs: "[{}]"
      ad.stackstate.com/exporter.instances: '[ { "prometheus_url": "http://%%host%%:9108/metrics", "namespace": "stackstate", "metrics": ["elasticsearch_indices_store_*", "elasticsearch_cluster_health_*"] } ]'
    resources:
      limits:
        cpu: "100m"
        memory: "100Mi"
        ephemeral-storage: "1Gi"
      requests:
        cpu: "100m"
        memory: "100Mi"
        ephemeral-storage: "1Mi"
    es:
      uri: http://stackstate-elasticsearch-master:9200
hbase:
  # hbase.enabled -- Enable / disable chart-based HBase.
  enabled: true
  # hbase.commonLabels -- Add additional labels to all resources created for all hbase resources
  commonLabels:
    app.kubernetes.io/part-of: stackstate-k8s
  all:
    metrics:
      enabled: true
      # stackstate.components.all.metrics.agentAnnotationsEnabled -- Put annotations on each pod to instruct the stackstate agent to scrape the metrics
      agentAnnotationsEnabled: true
  stackgraph:
    image:
      # hbase.stackgraph.image.tag -- The StackGraph server version, must be compatible with the StackState version
      tag: 4.14.0
  console:
    # hbase.console.enabled -- Enabled by default for debugging, but with 0 replicas. Manually scale up to 1 replica and open a shell in the container to access the stackgraph console.
    enabled: true
  hbase:
    master:
      experimental:
        execLivenessProbe:
          enabled: true
      # hbase.hbase.master.replicaCount -- Number of HBase master node replicas.
      replicaCount: 2
      resources:
        limits:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1Gi"
          cpu: "50m"
          ephemeral-storage: "1Mi"
    regionserver:
      # hbase.hbase.regionserver.replicaCount -- Number of HBase regionserver node replicas.
      replicaCount: 3
      resources:
        limits:
          memory: "3Gi"
          cpu: "3000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "3Gi"
          cpu: "500m"
          ephemeral-storage: "1Mi"
  hdfs:
    # hbase.hdfs.minReplication -- Min number of copies we create from any data block. (If the hbase.hdfs.datanode.replicaCount is set to a lower value than this, we will use the replicaCount instead)
    minReplication: 2
    datanode:
      # hbase.hdfs.datanode.replicaCount -- Number of HDFS datanode replicas.
      replicaCount: 3
      resources:
        limits:
          memory: "4Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "4Gi"
          cpu: "100m"
          ephemeral-storage: "1Mi"
    namenode:
      resources:
        limits:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1Gi"
          cpu: "50m"
          ephemeral-storage: "1Mi"
    secondarynamenode:
      enabled: true
      resources:
        limits:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1Gi"
          cpu: "50m"
          ephemeral-storage: "1Mi"
  tephra:
    # hbase.tephra.replicaCount -- Number of Tephra replicas.
    replicaCount: 2
    resources:
      limits:
        memory: "3Gi"
        cpu: "500m"
        ephemeral-storage: "1Gi"
      requests:
        memory: "3Gi"
        cpu: "250m"
        ephemeral-storage: "1Mi"
  zookeeper:
    # hbase.zookeeper.enabled -- Disable Zookeeper from the HBase chart **Don't change unless otherwise specified**.
    enabled: false
    # hbase.zookeeper.externalServers -- External Zookeeper if not used bundled Zookeeper chart **Don't change unless otherwise specified**.
    externalServers: stackstate-zookeeper-headless
kafkaup-operator:
  enabled: true
  image:
    # kafkaup.image.registry -- Registry containing the image for the KafkaUp operator
    registry: quay.io
    # kafkaup.image.repository -- Repository containing the image for the KafkaUp operator
    repository: stackstate/kafkaup-operator
    # kafkaup.image.tag -- Tag of the image for the KafkaUp operator
    tag: 0.0.2
    # kafkaup.image.pullPolicy -- Pull policy for the image:pod for the KafkaUp operator
    pullPolicy: ""
  kafkaSelectors:
    # kafkaup.kafkaSelectors.statefulSetName -- name of the statefulSet to operate on
    statefulSetName: "stackstate-kafka"
    # kafkaup.kafkaSelectors.podLabel -- pod label of kafka pods to operate on
    podLabel:
      key: "app.kubernetes.io/component"
      value: "kafka"
  # kafkaup.startVersion -- The below version is the version at which we started to use the kafka
  # versioning operator, this should not be changed
  startVersion: "2.3.1"
kafka:
  # kafka.command -- Override kafka container command.
  command:
    - "/scripts/custom-setup.sh"
  externalZookeeper:
    # kafka.externalZookeeper.servers -- External Zookeeper if not used bundled Zookeeper chart **Don't change unless otherwise specified**.
    servers: stackstate-zookeeper-headless
  # kafka.enabled -- Enable / disable chart-based Kafka.
  enabled: true
  podLabels:
    app.kubernetes.io/part-of: stackstate-k8s
  volumePermissions:
    enabled: false
  ## kafka.defaultReplicationFactor -- Default replication factors for automatically created topics
  defaultReplicationFactor: 2
  ## kafka.offsetTopicReplicationFactor --  The replication factor for the offsets topic
  offsetsTopicReplicationFactor: 2
  ## kafka.transactionStateLogReplicationFactor -- The replication factor for the transaction topic
  transactionStateLogReplicationFactor: 2
  # kafka.extraDeploy -- Array of extra objects to deploy with the release
  extraDeploy:
    - apiVersion: v1
      kind: ConfigMap
      metadata:
        name: kafka-custom-scripts
      data:
        custom-setup.sh: |-
          #!/bin/bash

          ID="${MY_POD_NAME#"{{ include "common.names.fullname" . }}-"}"

          KAFKA_META_PROPERTIES=/bitnami/kafka/data/meta.properties
          if [[ -f ${KAFKA_META_PROPERTIES} ]]; then
            ID=`grep -e ^broker.id= ${KAFKA_META_PROPERTIES} | sed 's/^broker.id=//'`
            if [[ "${ID}" != "" ]] && [[ "${ID}" -gt 1000 ]]; then
              echo "Using broker ID ${ID} from ${KAFKA_META_PROPERTIES} for compatibility (STAC-9614)"
            fi
          fi

          export KAFKA_CFG_BROKER_ID="$ID"

          exec /entrypoint.sh /run.sh
  # kafka.extraEnvVars -- Extra environment variables to add to kafka pods.
  extraEnvVars:
    - name: KAFKA_CFG_RESERVED_BROKER_MAX_ID
      value: "2000"
    # How long will a producer linger when no data is flowing? We make this quite a high number to make
    # sure that in POC like settings, where there is not always much activity, transactional producer do not get kicked out.
    # See STAC-15583
    # Using MaxInt value, giving 25 days of retention on txIds
    - name: KAFKA_CFG_TRANSACTIONAL_ID_EXPIRATION_MS
      value: "2147483647"
  # kafka.extraVolumes -- Extra volume(s) to add to Kafka statefulset.
  extraVolumes:
    - name: kafka-custom-scripts
      configMap:
        name: kafka-custom-scripts
        defaultMode: 493
  # kafka.extraVolumeMounts -- Extra volumeMount(s) to add to Kafka containers.
  extraVolumeMounts:
    - name: kafka-custom-scripts
      mountPath: /scripts/custom-setup.sh
      subPath: custom-setup.sh
  # kafka.initContainers -- required to make the kafka versionup operator work
  initContainers:
    - name: check-inter-broker-protocol-version
      image: '{{ include "kafka.image" . }}'
      imagePullPolicy: ''
      command:
        - /bin/bash
      args:
        - -c
        - "while [ -z \"${KAFKA_CFG_INTER_BROKER_PROTOCOL_VERSION}\" ]; do echo \"KAFKA_CFG_INTER_BROKER_PROTOCOL_VERSION should be set by operator\"; sleep 1; done"
      resources:
        limits: {}
        requests: {}
  # kafka.fullnameOverride -- Name override for Kafka child chart. **Don't change unless otherwise specified; this is a Helm v2 limitation, and will be addressed in a later Helm v3 chart.**
  fullnameOverride: stackstate-kafka
  image:
    # kafka.image.registry -- Kafka image registry
    registry: quay.io
    # kafka.image.repository -- Kafka image repository
    repository: stackstate/kafka
    # kafka.image.tag -- Kafka image tag. **Since StackState relies on this specific version, it's advised NOT to change this.**
    # When changing this version, be sure to change the pod annotation stackstate.com/kafkaup-operator.kafka_version aswell, in order
    # for the kafkaup operator to upgrade the inter broker protocol version
    tag: 3.3.1-08305c25
  livenessProbe:
    # kafka.livenessProbe.initialDelaySeconds -- Delay before readiness probe is initiated.
    initialDelaySeconds: 240
  # kafka.logRetentionHours -- The minimum age of a log file to be eligible for deletion due to age.
  logRetentionHours: 24
  metrics:
    kafka:
      # kafka.metrics.kafka.enabled -- Whether or not to create a standalone Kafka exporter to expose Kafka metrics.
      enabled: false
    jmx:
      # kafka.metrics.jmx.enabled -- Whether or not to expose JMX metrics to Prometheus.
      enabled: true
      image:
        # kafka.metrics.jmx.image.registry -- Kafka JMX exporter image registry
        registry: quay.io
        # kafka.metrics.jmx.image.repository -- Kafka JMX exporter image repository
        repository: stackstate/jmx-exporter
        # kafka.metrics.jmx.image.tag -- Kafka JMX exporter image tag
        tag: 0.17.0-129c430a
      resources:
        limits:
          cpu: "1"
          memory: "300Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "200m"
          memory: "300Mi"
          ephemeral-storage: "1Mi"
    serviceMonitor:
      # kafka.metrics.serviceMonitor.enabled -- If `true`, creates a Prometheus Operator `ServiceMonitor` (also requires `kafka.metrics.kafka.enabled` or `kafka.metrics.jmx.enabled` to be `true`).
      enabled: false
      # kafka.metrics.serviceMonitor.interval -- How frequently to scrape metrics.
      interval: 20s
      # kafka.metrics.serviceMonitor.labels -- Add extra labels to target a specific prometheus instance
      labels: {}
  readinessProbe:
    # kafka.readinessProbe.initialDelaySeconds -- Delay before readiness probe is initiated.
    initialDelaySeconds: 45
  # kafka.replicaCount -- Number of Kafka replicas.
  replicaCount: 3
  # kafka.topicRetention -- Max time in milliseconds to retain data in each topic.
  topicRetention: "86400000"
  persistence:
    # kafka.persistence.size -- Size of persistent volume for each Kafka pod
    size: 100Gi
  # kafka.commonLabels -- Add additional labels to all resources created for kafka
  commonLabels:
    app.kubernetes.io/part-of: stackstate
  # kafka.podAnnotations -- Kafka Pod annotations.
  podAnnotations:
    ad.stackstate.com/jmx-exporter.check_names: '["openmetrics"]'
    ad.stackstate.com/jmx-exporter.init_configs: "[{}]"
    ad.stackstate.com/jmx-exporter.instances: '[ { "prometheus_url": "http://%%host%%:5556/metrics", "namespace": "stackstate", "metrics": ["*"] } ]'
    # When changing this version, be sure to also change the image, such that the image version and this version are in sync
    stackstate.com/kafkaup-operator.kafka_version: "3.3.1"
  # kafka.resources -- Kafka resources per pods.
  resources:
    limits:
      memory: "2Gi"
      cpu: "1000m"
      ephemeral-storage: "1Gi"
    requests:
      memory: "2Gi"
      cpu: "500m"
      ephemeral-storage: "1Mi"
  # kafka.zookeeper.enabled -- Disable Zookeeper from the Kafka chart **Don't change unless otherwise specified**.
  zookeeper:
    enabled: false
  topic:
    stsMetricsV2:
      partitionCount: 10
  pdb:
    ## kafka.pdb.create Deploy a pdb object for the Kafka pod
    create: true
    ## kafka.pdb.minAvailable Maximum number/percentage of unavailable Kafka replicas
    minAvailable: ""
    ## kafka.pdb.maxUnavailable Maximum number/percentage of unavailable Kafka replicas
    maxUnavailable: 1
minio:
  # minio.replicas -- Number of MinIO replicas.
  replicas: 1
  persistence:
    # minio.persistence.enabled -- Enables MinIO persistence. Must be enabled when MinIO is not configured as a gateway to AWS S3 or Azure Blob Storage.
    enabled: false
  # minio.fullnameOverride -- **N.B.: Do not change this value!** The fullname override for MinIO subchart is hardcoded so that the stackstate chart can refer to its components.
  fullnameOverride: stackstate-minio
  image:
    # minio.image.registry -- MinIO image registry
    registry: quay.io
    # minio.image.repository -- MinIO image repository
    repository: stackstate/minio
    tag: RELEASE.2021-02-14T04-01-33Z-ade00eeb
  # minio.accessKey -- Access key for MinIO. Default is set to an invalid value that will cause MinIO to not start up to ensure users of this Helm chart set an explicit value.
  accessKey: setme
  # minio.accessKey -- Secret key for MinIO. Default is set to an invalid value that will cause MinIO to not start up to ensure users of this Helm chart set an explicit value.
  secretKey: setme
  azuregateway:
    # azuregateway.replicas -- Number of azure gateway instances to run in parallel
    replicas: 1
  s3gateway:
    # s3gateway.replicas -- Number of s3 gateway instances to run in parallel
    replicas: 1
zookeeper:
  # zookeeper.enabled -- Enable / disable chart-based Zookeeper.
  enabled: true
  # zookeeper.externalServers -- If `zookeeper.enabled` is set to `false`, use this list of external Zookeeper servers instead.
  externalServers: ""
  # zookeeper.heapSize -- HeapSize Size (in MB) for the Java Heap options (Xmx and Xms)
  heapSize: 512
  # zookeeper.fourlwCommandsWhitelist -- Zookeeper four-letter-word (FLW) commands that are enabled.
  fourlwCommandsWhitelist: "mntr, ruok, stat, srvr"
  # zookeeper.fullnameOverride -- Name override for Zookeeper child chart. **Don't change unless otherwise specified; this is a Helm v2 limitation, and will be addressed in a later Helm v3 chart.**
  fullnameOverride: stackstate-zookeeper
  podLabels:
    app.kubernetes.io/part-of: stackstate-k8s
  commonLabels:
    app.kubernetes.io/part-of: stackstate
  livenessProbe:
    # zookeeper.livenessProbe.enabled -- it must be disabled to apply the custom probe, the probe adds "-q" option to nc to wait 1sec until close the connection, it fixes problem of failing the probed
    enabled: false
  customLivenessProbe:
    exec:
      command:
        - /bin/bash
        - -c
        - echo "ruok" | timeout 2 nc -w 2 -q 1 localhost 2181 | grep imok
    failureThreshold: 6
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  readinessProbe:
    # zookeeper.readinessProbe.enabled -- it must be disabled to apply the custom probe, the probe adds "-q" option to nc to wait 1sec until close the connection, it fixes problem of failing the probed
    enabled: false
  customReadinessProbe:
    exec:
      command:
        - /bin/bash
        - -c
        - echo "ruok" | timeout 2 nc -w 2 -q 1 localhost 2181 | grep imok
    failureThreshold: 6
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5
  image:
    # zookeeper.image.registry -- ZooKeeper image registry
    registry: quay.io
    # zookeeper.image.repository -- ZooKeeper image repository
    repository: stackstate/zookeeper
    # zookeeper.image.tag -- ZooKeeper image tag
    tag: 3.6.3-5e3ee3c0
  metrics:
    # zookeeper.metrics.enabled -- Enable / disable Zookeeper Prometheus metrics.
    enabled: true
    # zookeeper.metrics.serviceMonitor --
    serviceMonitor:
      # zookeeper.metrics.serviceMonitor.enabled -- Enable creation of `ServiceMonitor` objects for Prometheus operator.
      enabled: false
      # zookeeper.metrics.serviceMonitor.selector -- Default selector to use to target a certain Prometheus instance.
      selector: {}
  resources:
    limits:
      # zookeeper.resources.limits.memory -- Allocated memory should be bigger than JVM Heap Size (env var ZOO_HEAP_SIZE) and space used by Off-Heap Memory (e.g. Metaspace)
      memory: "640Mi"
      cpu: "250m"
      ephemeral-storage: "1Gi"
    requests:
      # zookeeper.resources.requests.memory -- Allocated memory should be bigger than JVM Heap Size (env var ZOO_HEAP_SIZE) and space used by Off-Heap Memory (e.g. Metaspace)
      memory: "640Mi"
      cpu: "100m"
      ephemeral-storage: "1Mi"
  # zookeeper.podAnnotations -- Annotations for ZooKeeper pod.
  podAnnotations:
    ad.stackstate.com/zookeeper.check_names: '["openmetrics"]'
    ad.stackstate.com/zookeeper.init_configs: "[{}]"
    ad.stackstate.com/zookeeper.instances: '[ { "prometheus_url": "http://%%host%%:9141/metrics", "namespace": "stackstate", "metrics": ["*"] } ]'
  # zookeeper.replicaCount -- Default amount of Zookeeper replicas to provision.
  replicaCount: 3
  pdb:
    ## zookeeper.pdb.create Deploy a pdb object for the Zookeeper pod
    create: true
    ## zookeeper.pdb.minAvailable Maximum number/percentage of unavailable Zookeeper replicas
    minAvailable: ""
    ## zookeeper.pdb.maxUnavailable Maximum number/percentage of unavailable Zookeeper replicas
    maxUnavailable: 1
anomaly-detection:
  # anomaly-detection.enabled -- Enables anomaly detection chart
  enabled: false
  cpu:
    # anomaly-detection.cpu.limit -- CPU resource limit
    limit: "2000m"
    # anomaly-detection.cpu.request -- CPU resource request
    request: "1000m"
  memory:
    # anomaly-detection.memory.limit -- Memory resource limit
    limit: "3Gi"
    # anomaly-detection.memory.request -- Memory resource request
    request: "3Gi"
  pdb:
    # anomaly-detection.pdb.maxUnavailable -- Maximum number of pods that can be unavailable for the anomaly detection
    maxUnavailable: 0
  image:
    # anomaly-detection.image.imagePullPolicy -- The default pullPolicy used for anomaly detection pods.
    imagePullPolicy: IfNotPresent
    # 'tag' is commented here since we take the latest image tag compatible with stackstate chart from anomaly-detection sub-chart
    # It is still possible to override it here.
    # anomaly-detection.image.tag -- the chart image tag, e.g. 4.1.3-latest
    # tag:

    # anomaly-detection.image.pullSecretName -- Name of ImagePullSecret to use for all pods.
    pullSecretName:
    # anomaly-detection.image.pullSecretUsername -- Username used to login to the registry to pull Docker images of all pods.
    pullSecretUsername:
    # anomaly-detection.image.pullSecretUsername -- Password used to login to the registry to pull Docker images of all pods.
    pullSecretPassword:
    # anomaly-detection.image.registry -- Base container image registry for all containers, except for the wait container
    registry: quay.io
    # anomaly-detection.image.spotlightRepository -- Repository of the spotlight Docker image.
    spotlightRepository: stackstate/spotlight
  stackstate:
    # anomaly-detection.stackstate.instance -- **Required Stackstate instance URL, e.g http://stackstate-router:8080
    instance: 'http://{{ include "stackstate.hostname.prefix" . }}-router:8080'
    # anomaly-detection.stackstate.authType -- Type of authentication. There are three options 1) "token" - with service account token (default), 2) "api-token" - with Stackstate API Token, 3) "cookie" - username, password based auth.
    authType: token
    # anomaly-detection.stackstate.username -- Stackstate Username used by spotlight for authentication, it is expected to be set only in case if authType = "cookie"
    username:
    # anomaly-detection.stackstate.password -- Stackstate Password used by spotlight for authentication, it is expected to be set only in case if authType = "cookie"
    password:
    # anomaly-detection.stackstate.apiToken -- Stackstate Api token that used by spotlight for authentication, it is expected to be set only in case if authType = "api-token"
    apiToken:
  # anomaly-detection.threadWorkers -- The number of worker threads.
  threadWorkers: 3
  # anomaly-detection.ingress -- Status interface ingress
  ingress:
    # anomaly-detection.ingress.enabled -- Enables ingress controller for status interface
    enabled: false
    # anomaly-detection.ingress.hostname -- Status interface hostname e.g. spotlight.local.domain
    hostname:
    # anomaly-detection.ingress.port - Status Interface port
    port: 8090
    # anomaly-detection.ingress.annotations - Annotations for ingress objects.
    annotations: {}
    # e.g.
    #     kubernetes.io/ingress.class: nginx
    #     cert-manager.io/cluster-issuer: letsencrypt-prod
    #     external-dns.alpha.kubernetes.io/hostname: spotlight.local.domain
    #     nginx.ingress.kubernetes.io/ingress.class: nginx
    #     nginx.ingress.kubernetes.io/proxy-body-size: 100m
    #     nginx.ingress.kubernetes.io/rewrite-target: "/$1"
    # anomaly-detection.ingress.hosts - List of ingress hostnames
    hosts: []
    # - host: spotlight.local.domain

    # anomaly-detection.ingress.tls - List of ingress TLS certificates to use.
    tls:
    # - hosts:
    #     - spotlight.local.domain
cluster-role:
  # cluster-role.enabled -- Deploy the ClusterRole(s) and ClusterRoleBinding(s) together with the chart. Can be disabled if these need to be installed by an administrator of the Kubernetes cluster.
  enabled: true
pull-secret:
  # pull-secret.enabled -- Deploy the ImagePullSecret for the chart.
  enabled: false
  # pull-secret.fullNameOverride -- Name of the ImagePullSecret that will be created. This can be referenced by setting the `global.imagePullSecrets[0].name` value in the chart.
  fullNameOverride: ''
  # pull-secret.credentials -- Registry and assotiated credentials (username, password) that will be stored in the pull-secret
  credentials: []
victoria-metrics-0:
  enabled: true
  rbac:
    # victoria-metrics-0.pspEnabled -- Pod Security Policy has been deprecated and even removed from 1.25, we're not going to use it anymore
    pspEnabled: false
    # victoria-metrics-0.namespaced -- Make sure all resources are namespaced
    namespaced: true
  server:
    # victoria-metrics-0.server.fullnameOverride -- Full name override
    fullnameOverride: stackstate-victoria-metrics-0
    image:
      # victoria-metrics-0.server.image.repository -- Victoriametrics repository
      repository: quay.io/stackstate/victoria-metrics
      # 1.93.x is the LTS version
      tag: "v1.93.7-3f3a60fc"
    # victoria-metrics-0.server.podAnnotations -- Annotations for Victoria Metrics server pod
    podAnnotations:
      ad.stackstate.com/victoria-metrics-0-server.check_names: '["openmetrics"]'
      ad.stackstate.com/victoria-metrics-0-server.init_configs: "[{}]"
      ad.stackstate.com/victoria-metrics-0-server.instances: '[ { "prometheus_url": "http://%%host%%:8428/metrics", "namespace": "stackstate", "metrics": ["*"] } ]'
      ad.stackstate.com/vmbackup.check_names: '["openmetrics"]'
      ad.stackstate.com/vmbackup.init_configs: "[{}]"
      ad.stackstate.com/vmbackup.instances: '[ { "prometheus_url": "http://%%host%%:9746/metrics", "namespace": "stackstate", "metrics": ["supercronic_*"] } ]'
    # victoria-metrics-0.server.affinity -- Affinity settings for Victoria Metrics pod
    affinity: {}
    # podAntiAffinity:
    #   preferredDuringSchedulingIgnoredDuringExecution:
    #   - podAffinityTerm:
    #       labelSelector:
    #         matchLabels:
    #           app.kubernetes.io/name: victoria-metrics-single
    #           app: server
    #       namespaces:
    #       - <the-namespace>
    #       topologyKey: kubernetes.io/hostname
    #     weight: 1
    # victoria-metrics-0.server.podLabels -- Extra labels for Victoria Metrics pod
    podLabels:
      stackstate-service: victoriametrics
      app.kubernetes.io/part-of: stackstate-k8s
    # victoria-metrics-0.server.extraLabels -- Extra labels for Victoria Metrics StatefulSet
    extraLabels:
      app.kubernetes.io/part-of: stackstate-k8s
    # victoria-metrics-0.server.extraArgs -- Extra arguments for Victoria Metrics
    extraArgs:
      dedup.minScrapeInterval: 1ms
      maxLabelsPerTimeseries: 35
    persistentVolume:
      # victoria-metrics-0.server.persistentVolume.size -- Size of storage for Victoria Metrics, ideally 20% of free space remains available at all times
      size: 250Gi
    # victoria-metrics-0.server.retentionPeriod -- How long is data retained, when changing also consider updating the persistentVolume.size to match. The following optional suffixes are supported: h (hour), d (day), w (week), y (year). If suffix isn't set, then the duration is counted in months (default 1)
    retentionPeriod: 1
    # victoria-metrics-0.server.resources - CPU/Memory requests and limits
    resources:
      requests:
        cpu: 300m
        memory: 3584Mi
      limits:
        memory: 4Gi
        cpu: 1
    scrape:
      # victoria-metrics-0.server.scrape.enabled -- StackState doesn't use the scraping of VictoriaMetrics
      enabled: false
    # victoria-metrics-0.server.securityContext -- Custom security context settings for running as non-root
    securityContext:
      runAsUser: 65534
      runAsGroup: 65534
      fsGroup: 65534
    serviceMonitor:
      # victoria-metrics-0.server.serviceMonitor.enabled -- If `true`, creates a Prometheus Operator `ServiceMonitor`
      enabled: false
      # victoria-metrics-0.server.serviceMonitor.interval -- Scrape interval for service monitor
      interval: 15s
      # victoria-metrics-0.server.serviceMonitor.extraLabels -- Add extra labels to target a specific prometheus instance
      extraLabels: {}
  backup:
    # victoria-metrics-0.backup.enabled -- Enable scheduled backups of Victoria Metrics. It requires to be enabled MinIO 'backup.enabled'.
    enabled: false
    # victoria-metrics-0.backup.bucketName -- Name of the MinIO bucket where Victoria Metrics backups are stored.
    bucketName: 'sts-victoria-metrics-backup'
    # victoria-metrics-1.backup.s3Prefix -- Prefix (dir name) used to store backup files, we may have multiple instances of Victoria Metrics, each of them should be stored into their own directory.
    s3Prefix: victoria-metrics-0
    scheduled:
      # victoria-metrics-0.backup.scheduled.schedule -- Cron schedule for automatic backups of Victoria Metrics
      schedule: '25 * * * *'
  restore:
    # victoria-metrics-0.restore.enabled -- Enable Victoria Metrics restore functionality (if `backup.enabled` is set to `true`).
    enabled: false
victoria-metrics-1:
  enabled: true
  rbac:
    # victoria-metrics-1.pspEnabled -- Pod Security Policy has been deprecated and even removed from 1.25, we're not going to use it anymore
    pspEnabled: false
    # victoria-metrics-1.namespaced -- Make sure all resources are namespaced
    namespaced: true
  server:
    # victoria-metrics-1.server.fullnameOverride -- Full name override
    fullnameOverride: stackstate-victoria-metrics-1
    image:
      # victoria-metrics-1.server.image.repository -- Victoriametrics repository
      repository: quay.io/stackstate/victoria-metrics
      # 1.93.x is the LTS version
      tag: "v1.93.7-3f3a60fc"
    # victoria-metrics-1.server.podAnnotations -- Annotations for Victoria Metrics server pod
    podAnnotations:
      ad.stackstate.com/victoria-metrics-0-server.check_names: '["openmetrics"]'
      ad.stackstate.com/victoria-metrics-0-server.init_configs: "[{}]"
      ad.stackstate.com/victoria-metrics-0-server.instances: '[ { "prometheus_url": "http://%%host%%:8428/metrics", "namespace": "stackstate", "metrics": ["*"] } ]'
      ad.stackstate.com/vmbackup.check_names: '["openmetrics"]'
      ad.stackstate.com/vmbackup.init_configs: "[{}]"
      ad.stackstate.com/vmbackup.instances: '[ { "prometheus_url": "http://%%host%%:9746/metrics", "namespace": "stackstate", "metrics": ["supercronic_*"] } ]'
    # victoria-metrics-1.server.affinity -- Affinity settings for Victoria Metrics pod
    affinity: {}
    # podAntiAffinity:
    #   preferredDuringSchedulingIgnoredDuringExecution:
    #   - podAffinityTerm:
    #       labelSelector:
    #         matchLabels:
    #           app.kubernetes.io/name: victoria-metrics-single
    #           app: server
    #       namespaces:
    #       - <the-namespace>
    #       topologyKey: kubernetes.io/hostname
    #     weight: 1
    # victoria-metrics-1.server.podLabels -- Extra arguments for Victoria Metrics pod
    podLabels:
      stackstate-service: victoriametrics
      app.kubernetes.io/part-of: stackstate-k8s
    # victoria-metrics-0.server.extraLabels -- Extra labels for Victoria Metrics StatefulSet
    extraLabels:
      app.kubernetes.io/part-of: stackstate-k8s
    # victoria-metrics-1.server.extraArgs -- Extra arguments for Victoria Metrics
    extraArgs:
      dedup.minScrapeInterval: 1ms
      maxLabelsPerTimeseries: 35
    persistentVolume:
      # victoria-metrics-1.server.persistentVolume.size -- Size of storage for Victoria Metrics, ideally 20% of free space remains available at all times
      size: 250Gi
    # victoria-metrics-1.server.retentionPeriod -- How long is data retained, when changing also consider updating the persistentVolume.size to match. The following optional suffixes are supported: h (hour), d (day), w (week), y (year). If suffix isn't set, then the duration is counted in months (default 1)
    retentionPeriod: 1
    # victoria-metrics-1.server.resources - CPU/Memory requests and limits
    resources:
      requests:
        cpu: 300m
        memory: 3584Mi
      limits:
        memory: 4Gi
        cpu: 1
    scrape:
      # victoria-metrics-1.server.scrape.enabled -- StackState doesn't use the scraping of VictoriaMetrics
      enabled: false
    # victoria-metrics-1.server.securityContext -- Custom security context settings for running as non-root
    securityContext:
      runAsUser: 65534
      runAsGroup: 65534
      fsGroup: 65534
    serviceMonitor:
      # victoria-metrics-1.server.serviceMonitor.enabled -- If `true`, creates a Prometheus Operator `ServiceMonitor`
      enabled: false
      # victoria-metrics-1.server.serviceMonitor.interval -- Scrape interval for service monitor
      interval: 15s
      # victoria-metrics-1.server.serviceMonitor.extraLabels -- Add extra labels to target a specific prometheus instance
      extraLabels: {}
  backup:
    # victoria-metrics-1.backup.enabled -- Enable scheduled backups of Victoria Metrics. It requires to be enabled MinIO 'backup.enabled'.
    enabled: false
    # victoria-metrics-1.backup.bucketName -- Name of the MinIO bucket where Victoria Metrics backups are stored.
    bucketName: 'sts-victoria-metrics-backup'
    # victoria-metrics-1.backup.s3Prefix -- Prefix (dir name) used to store backup files, we may have multiple instances of Victoria Metrics, each of them should be stored into their own directory.
    s3Prefix: victoria-metrics-1
    scheduled:
      # victoria-metrics-1.backup.scheduled.schedule -- Cron schedule for automatic backups of Victoria Metrics
      schedule: '35 * * * *'
  restore:
    # victoria-metrics-1.restore.enabled -- Enable Victoria Metrics restore functionality (if `backup.enabled` is set to `true`).
    enabled: false
victoria-metrics:
  restore:
    image:
      # victoria-metrics.restore.image.registry -- Base container image registry for 'vmrestore' containers.
      registry: quay.io
      # victoria-metrics.restore.image.repository -- Base container image repository for 'vmrestore' containers.
      repository: stackstate/vmrestore
      # victoria-metrics.restore.image.tag -- Container image tag for 'vmrestore' containers.
      tag: v1.93.7-09d9481f
      # victoria-metrics.restore.image.pullPolicy -- Image pull policy for `vmrestore` containers.
      pullPolicy: IfNotPresent
    securityContext:
      # backup.stackGraph.securityContext.enabled -- Whether or not to enable the securityContext
      enabled: true
      # backup.stackGraph.securityContext.fsGroup -- The GID (group ID) of all files on all mounted volumes
      fsGroup: 65534
      # backup.stackGraph.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
      runAsGroup: 65534
      # backup.stackGraph.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
      runAsNonRoot: true
      # backup.stackGraph.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
      runAsUser: 65534
