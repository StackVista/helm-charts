#####################
# StackState values #
#####################
global:
  # global.receiverApiKey -- API key to be used by the Receiver; if no key is provided, a random one will be generated for you.
  receiverApiKey: ""
  # global.imagePullSecrets -- List of image pull secret names to be used by all images across all charts.
  imagePullSecrets: []
# commonLabels -- Labels that will be added to all resources created by the stackstate chart (not the subcharts though)
commonLabels: {}
backup:
  # backup.additionalLogging -- Additional logback config for backup components
  additionalLogging: ""
  # backup.enabled -- Enables backup/restore, including the MinIO subsystem.
  enabled: false
  elasticsearch:
    # backup.elasticsearch.bucketName -- Name of the MinIO bucket where ElasticSearch snapshots are stored.
    bucketName: 'sts-elasticsearch-backup'
    # backup.elasticsearch.snapshotRepositoryName -- Name of the ElasticSearch snapshot repository.
    snapshotRepositoryName: 'sts-backup'
    restore:
      # backup.elasticsearch.restore.enabled -- Enable ElasticSearch snapshot restore functionality (if `backup.enabled` is set to `true`).
      enabled: true
    scheduled:
      # backup.elasticsearch.scheduled.enabled -- Enable scheduled ElasticSearch snapshots (if `backup.enabled` is set to `true`).
      enabled: true
      # backup.elasticsearch.scheduled.schedule -- Cron schedule for automatic ElasticSearch snaphosts in [ElastichSearch cron schedule syntax](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/cron-expressions.html).
      schedule: '0 0 3 * * ?'
      # backup.elasticsearch.scheduled.indices -- ElasticSearch indices to snapshot in [JSON array format](https://www.w3schools.com/js/js_json_arrays.asp).
      indices: "sts*"
      # backup.elasticsearch.scheduled.snapshotPolicyName -- Name of the ElasticSearch snapshot policy.
      snapshotPolicyName: 'auto-sts-backup'
      # backup.elasticsearch.scheduled.snapshotNameTemplate -- Template for the ElasticSearch snapshot name in [ElasticSearch date math format](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/date-math-index-names.html).
      snapshotNameTemplate: "<sts-backup-{now{yyyyMMdd-HHmm}}>"
      # backup.elasticsearch.scheduled.snapshotRetentionExpireAfter -- Amount of time to keep ElasticSearch snapshots in [ElasticSearch time units](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/common-options.html#time-units). *Note:* By default, the retention task itself [runs daily at 1:30 AM UTC](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/slm-settings.html#slm-retention-schedule).
      snapshotRetentionExpireAfter: "30d"
      # backup.elasticsearch.scheduled.snapshotRetentionMinCount -- Minimum number of ElasticSearch snapshots to keep. *Note:* By default, the retention task itself [runs daily at 1:30 AM UTC](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/slm-settings.html#slm-retention-schedule).
      snapshotRetentionMinCount: "5"
      # backup.elasticsearch.scheduled.snapshotRetentionMaxCount -- Minimum number of ElasticSearch snapshots to keep. *Note:* By default, the retention task itself [runs daily at 1:30 AM UTC](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/slm-settings.html#slm-retention-schedule).
      snapshotRetentionMaxCount: "30"
  poddisruptionbudget:
    # backup.poddisruptionbudget.maxUnavailable -- Maximum number of pods that can be unavailable during the backup.
    maxUnavailable: 0
  stackGraph:
    # backup.stackGraph.bucketName -- Name of the MinIO bucket to store StackGraph backups.
    bucketName: 'sts-stackgraph-backup'
    restore:
      # backup.stackGraph.restore.enabled -- Enable StackGraph backup restore functionality (if `backup.enabled` is set to `true`).
      enabled: true
      tempData:
        # backup.stackGraph.restore.tmpData.accessModes -- Access mode for temporary backup data.
        accessModes: ["ReadWriteOnce"]
        # backup.stackGraph.restore.tmpData.size -- Size of volume for temporary backup data -- must be large enough to store a single backup.
        size: '{{ .Values.hbase.hdfs.datanode.persistence.size }}'
        # backup.stackGraph.restore.tmpData.storageClass -- Storage class of the volume for temporary backup data.
        storageClass:
    scheduled:
      # backup.stackGraph.scheduled.enabled -- Enable scheduled StackGraph backups (if `backup.enabled` is set to `true`).
      enabled: true
      # backup.stackGraph.scheduled.schedule -- Cron schedule for automatic StackGraph backups in [Kubernetes cron schedule syntax](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax).
      schedule: '0 3 * * *'
      # backup.stackGraph.scheduled.backupNameTemplate -- Template for the StackGraph backup name as a double-quoted shell string value.
      backupNameTemplate: 'sts-backup-$(date +%Y%m%d-%H%M).graph'
      # backup.stackGraph.scheduled.backupNameParseRegexp -- Regular expression to retrieve date/time from StackGraph backup name. *Note:* This should match the value for `backupNameTemplate`.
      backupNameParseRegexp: 'sts-backup-([0-9]*-[0-9]*).graph'
      # backup.stackGraph.scheduled.backupDatetimeParseFormat -- Format to parse date/time from StackGraph backup name. *Note:* This should match the value for `backupNameTemplate`.
      backupDatetimeParseFormat: '%Y%m%d-%H%M'
      # backup.stackGraph.scheduled.backupRetentionTimeDelta -- Time to keep StackGraph backups in [Python timedelta format](https://docs.python.org/3/library/datetime.html#timedelta-objects).
      backupRetentionTimeDelta: 'days = 30'
      tempData:
        # backup.stackGraph.scheduled.tmpData.accessModes -- Access mode for temporary backup data.
        accessModes: ["ReadWriteOnce"]
        # backup.stackGraph.scheduled.tmpData.size -- Size of volume for temporary backup data -- must be large enough to store a single backup.
        size: '{{ .Values.hbase.hdfs.datanode.persistence.size }}'
        # backup.stackGraph.scheduled.tmpData.storageClass -- Storage class of the volume for temporary backup data.
        storageClass:
    securityContext:
      # backup.stackGraph.securityContext.enabled -- Whether or not to enable the securityContext
      enabled: true
      # backup.stackGraph.securityContext.fsGroup -- The GID (group ID) of all files on all mounted volumes
      fsGroup: 65534
      # backup.stackGraph.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
      runAsGroup: 65534
      # backup.stackGraph.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
      runAsNonRoot: true
      # backup.stackGraph.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
      runAsUser: 65534
  configuration:
    # backup.configuration.bucketName -- Name of the MinIO bucket to store configuration backups.
    bucketName: 'sts-configuration-backup'
    restore:
      # backup.configuration.restore.enabled -- Enable configuration backup restore functionality (if `backup.enabled` is set to `true`).
      enabled: true
    scheduled:
      # backup.configuration.scheduled.enabled -- Enable scheduled configuration backups (if `backup.enabled` is set to `true`).
      enabled: true
      # backup.configuration.scheduled.schedule -- Cron schedule for automatic configuration backups in [Kubernetes cron schedule syntax](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax).
      schedule: '0 4 * * *'
      # backup.configuration.scheduled.backupNameTemplate -- Template for the configuration backup name as a double-quoted shell string value.
      backupNameTemplate: 'sts-backup-$(date +%Y%m%d-%H%M).stj'
      # backup.configuration.scheduled.backupNameParseRegexp -- Regular expression to retrieve date/time from configuration backup name. *Note:* This should match the value for `backupNameTemplate`.
      backupNameParseRegexp: 'sts-backup-([0-9]*-[0-9]*).stj'
      # backup.configuration.scheduled.backupDatetimeParseFormat -- Format to parse date/time from configuration backup name. *Note:* This should match the value for `backupNameTemplate`.
      backupDatetimeParseFormat: '%Y%m%d-%H%M'
      # backup.configuration.scheduled.backupRetentionTimeDelta -- Time to keep configuration backups in [Python timedelta format](https://docs.python.org/3/library/datetime.html#timedelta-objects).
      backupRetentionTimeDelta: 'days = 365'
    securityContext:
      # backup.configuration.securityContext.enabled -- Whether or not to enable the securityContext
      enabled: true
      # backup.configuration.securityContext.fsGroup -- The GID (group ID) of all files on all mounted volumes
      fsGroup: 65534
      # backup.configuration.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
      runAsGroup: 65534
      # backup.configuration.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
      runAsNonRoot: true
      # backup.configuration.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
      runAsUser: 65534
caspr:
  # caspr.enabled -- Enable CASPR compatible values.
  enabled: false
ingress:
  # ingress.annotations -- Annotations for ingress objects.
  annotations: {}
  # kubernetes.io/ingress.class: nginx
  # kubernetes.io/tls-acme: "true"
  # ingress.enabled -- Enable use of ingress controllers.
  enabled: false
  path: /
  # ingress.hosts -- List of ingress hostnames; the paths are fixed to StackState backend services
  hosts: []
  # - host: stackstate.local
  # ingress.tls -- List of ingress TLS certificates to use.
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - stackstate.local
networkPolicy:
  # networkPolicy.enabled -- Enable creating of `NetworkPolicy` object and associated rules for StackState.
  enabled: false
  # networkPolicy.spec -- `NetworkPolicy` rules for StackState.
  spec:
    ingress:
      - from:
          - podSelector: {}
    podSelector:
      matchLabels: {}
    policyTypes:
      - Ingress
stackstate:
  components:
    all:
      # stackstate.components.all.deploymentStrategy.type -- Deployment strategy for StackState components. Possible values: `RollingUpdate`, `Recreate` and `RecreateSingletonsOnly`.
      # `RecreateSingletonsOnly` uses `Recreate` for the singleton Deployments and `RollingUpdate` for the other Deployments.
      deploymentStrategy:
        type: RecreateSingletonsOnly
      extraEnv:
        # stackstate.components.all.extraEnv.open -- Extra open environment variables to inject into pods for all components.
        open: {}
        # stackstate.components.all.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object for all components.
        secret: {}
      image:
        # stackstate.components.all.image.registry -- Base container image registry for all StackState containers, except for the wait container and the container-tools container
        registry: quay.io
        # stackstate.components.all.image.repositorySuffix - String to append to repositories for StackState components
        repositorySuffix: "-stable"
        # stackstate.components.all.image.pullSecretName -- Name of ImagePullSecret to use for all pods.
        pullSecretName:
        # all.image.pullSecretUsername -- Username used to login to the registry to pull Docker images of all pods.
        pullSecretUsername:
        # all.image.pullSecretPassword -- Password used to login to the registry to pull Docker images of all pods.
        pullSecretPassword:
        # stackstate.components.all.image.pullPolicy -- The default pullPolicy used for all stateless components of StackState; invividual service `pullPolicy`s can be overriden (see below).
        pullPolicy: IfNotPresent
        # When changing this value make sure to also update hbase.stackgraph.image.tag to the matching StackGraph version
        # stackstate.components.all.image.tag -- The default tag used for all stateless components of StackState; invividual service `tag`s can be overriden (see below).
        tag: 5.1.4
      metrics:
        # stackstate.components.all.metrics.enabled -- Enable metrics port.
        enabled: true
        # stackstate.components.all.metrics.agentAnnotationsEnabled -- Put annotations on each pod to instruct the stackstate agent to scrape the metrics
        agentAnnotationsEnabled: true
        servicemonitor:
          # stackstate.components.all.metrics.servicemonitor.additionalLabels -- Additional labels for targeting Prometheus operator instances.
          additionalLabels: {}
          # stackstate.components.all.metrics.servicemonitor.enabled -- Enable `ServiceMonitor` object; `all.metrics.enabled` *must* be enabled.
          enabled: false
      securityContext:
        # stackstate.components.all.securityContext.enabled -- Whether or not to enable the securityContext
        enabled: true
        # stackstate.components.all.securityContext.fsGroup -- The GID (group ID) used to mount volumes
        fsGroup: 65534
        # stackstate.components.all.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
        runAsGroup: 65534
        # stackstate.components.all.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
        runAsNonRoot: true
        # stackstate.components.all.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
        runAsUser: 65534
      # stackstate.components.all.elasticsearchEndpoint -- **Required if `elasticsearch.enabled` is `false`** Endpoint for shared Elasticsearch cluster.
      elasticsearchEndpoint: ""
      # stackstate.components.all.kafkaEndpoint -- **Required if `elasticsearch.enabled` is `false`** Endpoint for shared Kafka broker.
      kafkaEndpoint: ""
      # stackstate.components.all.zookeeperEndpoint -- **Required if `zookeeper.enabled` is `false`** Endpoint for shared Zookeeper nodes.
      zookeeperEndpoint: ""
      # stackstate.components.all.nodeSelector -- Node labels for pod assignment on all components.
      nodeSelector: {}
      # stackstate.components.all.tolerations -- Toleration labels for pod assignment on all components.
      tolerations: []
      # stackstate.components.all.affinity -- Affinity settings for pod assignment on all components.
      affinity: {}
    api:
      extraEnv:
        # stackstate.components.api.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.api.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.api.image.pullPolicy -- `pullPolicy` used for the `api` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.api.image.repository -- Repository of the api component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.api.image.tag -- Tag used for the `api` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.api.poddisruptionbudget -- PodDisruptionBudget settings for `api` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.api.resources -- Resource allocation for `api` pods.
      resources:
        limits:
          memory: "4000Mi"
          cpu: "2000m"
          ephemeral-storage: "2Gi"
        requests:
          memory: "4000Mi"
          cpu: "1500m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "50"
      # stackstate.components.api.replicaCount -- Number of `api` replicas.
      replicaCount: 1
      # stackstate.components.api.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.api.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.api.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.api.config -- Configuration file contents to customize the default StackState api configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.api.additionalLogging -- Additional logback config
      additionalLogging: ""
      # stackstate.components.api.docslink -- Documentation URL root to use in the product help page & tooltips.
      docslink: ""
    backup:
      resources:
        limits:
          memory: "4000Mi"
          cpu: "3000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "4000Mi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
    correlate:
      extraEnv:
        # stackstate.components.correlate.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.correlate.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.correlate.image.pullPolicy -- `pullPolicy` used for the `correlate` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.correlate.image.repository -- Repository of the correlate component Docker image.
        repository: stackstate/stackstate-correlate
        # stackstate.components.correlate.image.tag -- Tag used for the `correlate` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.correlate.poddisruptionbudget -- PodDisruptionBudget settings for `correlate` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.correlate.resources -- Resource allocation for `correlate` pods.
      resources:
        limits:
          memory: "1600Mi"
          cpu: "2"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1600Mi"
          cpu: "2"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "575Mi"
        javaHeapMemoryFraction: "78"
      # stackstate.components.correlate.replicaCount -- Number of `correlate` replicas.
      replicaCount: 1
      # stackstate.components.correlate.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.correlate.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.correlate.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.correlate.additionalLogging -- Additional logback config
      additionalLogging: ""
    checks:
      extraEnv:
        # stackstate.components.checks.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.checks.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.checks.image.pullPolicy -- `pullPolicy` used for the `state` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.checks.image.repository -- Repository of the sync component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.checks.image.tag -- Tag used for the `state` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.checks.poddisruptionbudget -- PodDisruptionBudget settings for `checks` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.checks.resources -- Resource allocation for `state` pods.
      resources:
        limits:
          memory: "4000Mi"
          cpu: "2000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "4000Mi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "70"
      # stackstate.components.checks.replicaCount -- Number of `checks` replicas.
      replicaCount: 1
      # stackstate.components.checks.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.checks.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.checks.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.checks.config -- Configuration file contents to customize the default StackState state configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.checks.additionalLogging -- Additional logback config
      additionalLogging: ""
    healthSync:
      extraEnv:
        # stackstate.components.healthSync.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.healthSync.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.healthSync.image.pullPolicy -- `pullPolicy` used for the `healthSync` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.healthSync.image.repository -- Repository of the healthSync component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.healthSync.image.tag -- Tag used for the `healthSync` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.healthSync.poddisruptionbudget -- PodDisruptionBudget settings for `healthSync` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.healthSync.resources -- Resource allocation for `healthSync` pods.
      resources:
        limits:
          memory: "2000Mi"
          cpu: "1500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "2000Mi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "1200Mi"
        javaHeapMemoryFraction: "85"
      # stackstate.components.healthSync.replicaCount -- Number of `healthSync` replicas.
      replicaCount: 1
      # stackstate.components.healthSync.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.healthSync.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.healthSync.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.healthSync.config -- Configuration file contents to customize the default StackState healthSync configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.healthSync.additionalLogging -- Additional logback config
      additionalLogging: ""
      cache:
        # stackstate.components.healthSync.cache.backend -- Type of cache backend used by the service, possible values are mapdb, rocksdb and inmemory
        backend: "mapdb"
    initializer:
      extraEnv:
        # stackstate.components.initializer.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.initializer.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.initializer.image.pullPolicy -- `pullPolicy` used for the `initializer` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.initializer.image.repository -- Repository of the initializer component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.initializer.image.tag -- Tag used for the `initializer` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.initializer.resources -- Resource allocation for `initializer` pods.
      resources:
        limits:
          memory: "700Mi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "700Mi"
          cpu: "500m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "460Mi"
        javaHeapMemoryFraction: "65"
      # stackstate.components.initializer.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.initializer.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.initializer.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.initializer.config -- Configuration file contents to customize the default StackState initializer configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.initializer.additionalLogging -- Additional logback config
      additionalLogging: ""
    mm2es:
      extraEnv:
        # stackstate.components.mm2es.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.mm2es.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.mm2es.image.pullPolicy -- `pullPolicy` used for the `mm2es` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.mm2es.image.repository -- Repository of the mm2es component Docker image.
        repository: stackstate/stackstate-kafka-to-es
        # stackstate.components.mm2es.image.tag -- Tag used for the `mm2es` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.mm2es.poddisruptionbudget -- PodDisruptionBudget settings for `mm2es` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.mm2es.resources -- Resource allocation for `mm2es` pods.
      resources:
        limits:
          memory: "1Gi"
          cpu: "1000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1Gi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "600Mi"
        javaHeapMemoryFraction: "85"
      # stackstate.components.mm2es.replicaCount -- Number of `mm2es` replicas.
      replicaCount: 1
      # stackstate.components.mm2es.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.mm2es.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.mm2es.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.mm2es.additionalLogging -- Additional logback config
      additionalLogging: ""
    e2es:
      extraEnv:
        # stackstate.components.e2es.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.e2es.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.e2es.image.pullPolicy -- `pullPolicy` used for the `e2es` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.e2es.image.repository -- Repository of the e2es component Docker image.
        repository: stackstate/stackstate-kafka-to-es
        # stackstate.components.e2es.image.tag -- Tag used for the `e2es` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.e2es.poddisruptionbudget -- PodDisruptionBudget settings for `e2es` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.e2es.resources -- Resource allocation for `e2es` pods.
      resources:
        limits:
          memory: "1500Mi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1500Mi"
          cpu: "500m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "600Mi"
        javaHeapMemoryFraction: "85"
      # stackstate.components.e2es.replicaCount -- Number of `e2es` replicas.
      replicaCount: 1
      # stackstate.components.e2es.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.e2es.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.e2es.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.e2es.additionalLogging -- Additional logback config
      additionalLogging: ""
    trace2es:
      extraEnv:
        # stackstate.components.trace2es.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.trace2es.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.trace2es.image.pullPolicy -- `pullPolicy` used for the `trace2es` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.trace2es.image.repository -- Repository of the trace2es component Docker image.
        repository: stackstate/stackstate-kafka-to-es
        # stackstate.components.trace2es.image.tag -- Tag used for the `trace2es` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.trace2es.poddisruptionbudget -- PodDisruptionBudget settings for `trace2es` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.trace2es.resources -- Resource allocation for `trace2es` pods.
      resources:
        limits:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "600Mi"
        javaHeapMemoryFraction: "85"
      # stackstate.components.trace2es.replicaCount -- Number of `trace2es` replicas.
      replicaCount: 1
      # stackstate.components.trace2es.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.trace2es.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.trace2es.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.trace2es.enabled -- Enable/disable the trace2es service
      enabled: true
      # stackstate.components.trace2es.additionalLogging -- Additional logback config
      additionalLogging: ""
    receiver:
      extraEnv:
        # stackstate.components.receiver.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.receiver.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.receiver.image.pullPolicy -- `pullPolicy` used for the `receiver` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.receiver.image.repository -- Repository of the receiver component Docker image.
        repository: stackstate/stackstate-receiver
        # stackstate.components.receiver.image.tag -- Tag used for the `receiver` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.receiver.poddisruptionbudget -- PodDisruptionBudget settings for `receiver` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.receiver.resources -- Resource allocation for `receiver` pods.
      resources:
        limits:
          memory: "4Gi"
          cpu: "3000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "4Gi"
          cpu: "3000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "700Mi"
        javaHeapMemoryFraction: "75"
      # stackstate.components.receiver.replicaCount -- Number of `receiver` replicas.
      replicaCount: 1
      # stackstate.components.receiver.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.receiver.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.receiver.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.receiver.additionalLogging -- Additional logback config
      additionalLogging: ""
    router:
      accesslog:
        # stackstate.components.router.accesslog.enabled -- Enable access logging on the router
        enabled: false
      extraEnv:
        # stackstate.components.router.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.router.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.router.image.pullPolicy -- `pullPolicy` used for the `router` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.router.image.registry -- Registry of the router component Docker image.
        registry: quay.io
        # stackstate.components.router.image.repository -- Repository of the router component Docker image.
        repository: stackstate/envoy
        # stackstate.components.router.image.tag -- Tag used for the `router` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: v1.19.1-2738711656
      # stackstate.components.router.poddisruptionbudget -- PodDisruptionBudget settings for `router` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.router.resources -- Resource allocation for `router` pods.
      resources:
        limits:
          cpu: "100m"
          memory: "128Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "100m"
          memory: "128Mi"
          ephemeral-storage: "1Mi"
      # stackstate.components.router.replicaCount -- Number of `router` replicas.
      replicaCount: 1
      # stackstate.components.router.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.router.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.router.affinity -- Affinity settings for pod assignment.
      affinity: {}
    server:
      extraEnv:
        # stackstate.components.server.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.server.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.server.image.pullPolicy -- `pullPolicy` used for the `server` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.server.image.repository -- Repository of the server component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.server.image.tag -- Tag used for the `server` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.server.poddisruptionbudget -- PodDisruptionBudget settings for `server` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.server.resources -- Resource allocation for `server` pods.
      resources:
        limits:
          memory: "8Gi"
          cpu: "3600m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "8Gi"
          cpu: "3600m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "1700Mi"
        javaHeapMemoryFraction: "85"
      # stackstate.components.server.replicaCount -- Number of `server` replicas.
      replicaCount: 1
      # stackstate.components.server.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.server.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.server.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.server.config -- Configuration file contents to customize the default StackState configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.server.additionalLogging -- Additional logback config
      additionalLogging: ""
    state:
      extraEnv:
        # stackstate.components.state.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.state.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.state.image.pullPolicy -- `pullPolicy` used for the `state` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.state.image.repository -- Repository of the sync component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.state.image.tag -- Tag used for the `state` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.state.poddisruptionbudget -- PodDisruptionBudget settings for `state` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.state.resources -- Resource allocation for `state` pods.
      resources:
        limits:
          cpu: "1000m"
          memory: "2000Mi"
          ephemeral-storage: "1Gi"
        requests:
          memory: "2000Mi"
          cpu: "750m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "80"
      # stackstate.components.state.replicaCount -- Number of `state` replicas.
      replicaCount: 1
      # stackstate.components.state.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.state.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.state.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.state.config -- Configuration file contents to customize the default StackState state configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.state.additionalLogging -- Additional logback config
      additionalLogging: ""
    sync:
      extraEnv:
        # stackstate.components.sync.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.sync.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.sync.image.pullPolicy -- `pullPolicy` used for the `sync` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.sync.image.repository -- Repository of the sync component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.sync.image.tag -- Tag used for the `sync` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.sync.poddisruptionbudget -- PodDisruptionBudget settings for `sync` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.sync.resources -- Resource allocation for `sync` pods.
      resources:
        limits:
          memory: "3500Mi"
          cpu: "3000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "3500Mi"
          cpu: "2000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "60"
      # stackstate.components.sync.replicaCount -- Number of `sync` replicas.
      replicaCount: 1
      # stackstate.components.sync.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.sync.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.sync.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.sync.config -- Configuration file contents to customize the default StackState sync configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.sync.additionalLogging -- Additional logback config
      additionalLogging: ""
      cache:
        # stackstate.components.sync.cache.backend -- Type of cache backend used by the service, possible values are mapdb, rocksdb and inmemory
        backend: "mapdb"
    slicing:
      extraEnv:
        # stackstate.components.slicing.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.slicing.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.slicing.image.pullPolicy -- `pullPolicy` used for the `slicing` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.slicing.image.repository -- Repository of the slicing component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.slicing.image.tag -- Tag used for the `slicing` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.slicing.resources -- Resource allocation for `slicing` pods.
      resources:
        limits:
          cpu: "1500m"
          memory: "1800Mi"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1800Mi"
          cpu: "1000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "60"
      # stackstate.components.slicing.replicaCount -- Number of `slicing` replicas.
      replicaCount: 1
      # stackstate.components.slicing.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.slicing.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.slicing.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.slicing.config -- Configuration file contents to customize the default StackState slicing configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.slicing.additionalLogging -- Additional logback config
      additionalLogging: ""
    ui:
      extraEnv:
        # stackstate.components.ui.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.ui.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.ui.image.pullPolicy -- `pullPolicy` used for the `ui` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.ui.image.repository -- Repository of the ui component Docker image.
        repository: stackstate/stackstate-ui
        # stackstate.components.ui.image.tag -- Tag used for the `ui` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.ui.poddisruptionbudget -- PodDisruptionBudget settings for `ui` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.ui.resources -- Resource allocation for `ui` pods.
      resources:
        limits:
          cpu: "50m"
          memory: "64Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "50m"
          memory: "64Mi"
          ephemeral-storage: "1Mi"
      securityContext:
        # stackstate.components.ui.securityContext.enabled -- Whether or not to enable the securityContext
        enabled: true
        # stackstate.components.ui.securityContext.fsGroup -- The GID (group ID) used to mount volumes
        fsGroup: 101
        # stackstate.components.ui.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
        runAsGroup: 101
        # stackstate.components.ui.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
        runAsNonRoot: true
        # stackstate.components.ui.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
        runAsUser: 101
      # stackstate.components.ui.replicaCount -- Number of `ui` replicas.
      replicaCount: 2
      # stackstate.components.ui.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.ui.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.ui.affinity -- Affinity settings for pod assignment.
      affinity: {}
    viewHealth:
      extraEnv:
        # stackstate.components.viewHealth.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.viewHealth.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.viewHealth.image.pullPolicy -- `pullPolicy` used for the `viewHealth` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.viewHealth.image.repository -- Repository of the viewHealth component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.viewHealth.image.tag -- Tag used for the `viewHealth` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.viewHealth.poddisruptionbudget -- PodDisruptionBudget settings for `viewHealth` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.viewHealth.resources -- Resource allocation for `viewHealth` pods.
      resources:
        limits:
          memory: "2700Mi"
          cpu: "2000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "2700Mi"
          cpu: "2000m"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "55"
      # stackstate.components.viewHealth.replicaCount -- Number of `viewHealth` replicas.
      replicaCount: 1
      # stackstate.components.viewHealth.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.viewHealth.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.viewHealth.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.viewHealth.config -- Configuration file contents to customize the default StackState viewHealth configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.viewHealth.additionalLogging -- Additional logback config
      additionalLogging: ""
    problemProducer:
      extraEnv:
        # stackstate.components.problemProducer.extraEnv.open -- Extra open environment variables to inject into pods.
        open: {}
        # stackstate.components.problemProducer.extraEnv.secret -- Extra secret environment variables to inject into pods via a `Secret` object.
        secret: {}
      image:
        # stackstate.components.problemProducer.image.pullPolicy -- `pullPolicy` used for the `problemProducer` component Docker image; this will override `stackstate.components.all.image.pullPolicy` on a per-service basis.
        pullPolicy: ""
        # stackstate.components.problemProducer.image.repository -- Repository of the problemProducer component Docker image.
        repository: stackstate/stackstate-server
        # stackstate.components.problemProducer.image.tag -- Tag used for the `problemProducer` component Docker image; this will override `stackstate.components.all.image.tag` on a per-service basis.
        tag: ""
      # stackstate.components.problemProducer.poddisruptionbudget -- PodDisruptionBudget settings for `problemProducer` pods.
      poddisruptionbudget:
        maxUnavailable: 1
      # stackstate.components.problemProducer.resources -- Resource allocation for `problemProducer` pods.
      resources:
        limits:
          cpu: "1000m"
          memory: "2000Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "500m"
          memory: "2000Mi"
          ephemeral-storage: "1Mi"
      sizing:
        baseMemoryConsumption: "500Mi"
        javaHeapMemoryFraction: "80"
      # stackstate.components.problemProducer.replicaCount -- Number of `problemProducer` replicas.
      replicaCount: 1
      # stackstate.components.problemProducer.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.problemProducer.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.problemProducer.affinity -- Affinity settings for pod assignment.
      affinity: {}
      # stackstate.components.problemProducer.config -- Configuration file contents to customize the default StackState problemProducer configuration, environment variables have higher precedence and can be used as overrides. StackState configuration is in the [HOCON](https://github.com/lightbend/config/blob/master/HOCON.md) format, see [StackState documentation](https://docs.stackstate.com/setup/installation/kubernetes/) for examples.
      config: ""
      # stackstate.components.problemProducer.additionalLogging -- Additional logback config
      additionalLogging: ""
    kafkaTopicCreate:
      image:
        # stackstate.components.kafkaTopicCreate.image.registry -- Base container image registry for kafka-topic-create containers.
        registry: quay.io
        # stackstate.components.kafkaTopicCreate.image.repository -- Base container image repository for kafka-topic-create containers.
        repository: stackstate/kafka
        # stackstate.components.kafkaTopicCreate.image.tag -- Container image tag for kafka-topic-create containers.
        tag: 2.8.1-2738720666
        # stackstate.components.kafkaTopicCreate.image.pullPolicy -- Image pull policy for kafka-topic-create containers.
        pullPolicy: IfNotPresent
      # stackstate.components.kafkaTopicCreate.resources -- Resource allocation for `kafkaTopicCreate` pods.
      resources:
        limits:
          cpu: "1000m"
          memory: "2000Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "500m"
          memory: "2000Mi"
          ephemeral-storage: "1Mi"
      securityContext:
        # stackstate.components.kafkaTopicCreate.securityContext.enabled -- Whether or not to enable the securityContext
        enabled: true
        # stackstate.components.kafkaTopicCreate.securityContext.fsGroup -- The GID (group ID) used to mount volumes
        fsGroup: 1001
        # stackstate.components.kafkaTopicCreate.securityContext.runAsGroup -- The GID (group ID) of the owning user of the process
        runAsGroup: 1001
        # stackstate.components.kafkaTopicCreate.securityContext.runAsNonRoot -- Ensure that the user is not root (!= 0)
        runAsNonRoot: true
        # stackstate.components.kafkaTopicCreate.securityContext.runAsUser -- The UID (user ID) of the owning user of the process
        runAsUser: 1001
      # stackstate.components.kafkaTopicCreate.nodeSelector -- Node labels for pod assignment.
      nodeSelector: {}
      # stackstate.components.kafkaTopicCreate.tolerations -- Toleration labels for pod assignment.
      tolerations: []
      # stackstate.components.kafkaTopicCreate.affinity -- Affinity settings for pod assignment.
      affinity: {}
    nginxPrometheusExporter:
      image:
        # stackstate.components.nginxPrometheusExporter.image.registry -- Base container image registry for nginx-prometheus-exporter containers.
        registry: quay.io
        # stackstate.components.nginxPrometheusExporter.image.repository -- Base container image repository for nginx-prometheus-exporter containers.
        repository: stackstate/nginx-prometheus-exporter
        # stackstate.components.nginxPrometheusExporter.image.tag -- Container image tag for nginx-prometheus-exporter containers.
        tag: 0.9.0-2738682730
        # stackstate.components.nginxPrometheusExporter.image.pullPolicy -- Image pull policy for nginx-prometheus-exporter containers.
        pullPolicy: IfNotPresent
    containerTools:
      image:
        # stackstate.components.containerTools.image.registry -- Base container image registry for container-tools containers.
        registry: quay.io
        # stackstate.components.containerTools.image.repository -- Base container image repository for container-tools containers.
        repository: stackstate/container-tools
        # stackstate.components.containerTools.image.tag -- Container image tag for container-tools containers.
        tag: 1.1.4
        # stackstate.components.containerTools.image.pullPolicy -- Image pull policy for container-tools containers.
        pullPolicy: IfNotPresent
      # stackstate.components.containerTools.resources -- Resource allocation for `kafkaTopicCreate` pods.
      resources:
        limits:
          cpu: "1000m"
          memory: "2000Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "500m"
          memory: "2000Mi"
          ephemeral-storage: "1Mi"
    wait:
      image:
        # stackstate.components.wait.image.registry -- Base container image registry for wait containers.
        registry: quay.io
        # stackstate.components.wait.image.repository -- Base container image repository for wait containers.
        repository: stackstate/wait
        # stackstate.components.wait.image.tag -- Container image tag for wait containers.
        tag: 1.0.7-2755960650
        # stackstate.components.wait.image.pullPolicy -- Image pull policy for wait containers.
        pullPolicy: IfNotPresent
  # stackstate.authentication -- Configure the authentication settings for StackState here. Only one of the authentication providers can be used, configuring multiple will result in an error.
  authentication:
    # stackstate.authentication.keycloak -- Use Keycloak as authentication provider. See [Configuring Keycloak](#configuring-keycloak).
    keycloak: {}
    # stackstate.authentication.ldap -- LDAP settings for StackState. See [Configuring LDAP](#configuring-ldap).
    ldap: {}
    # stackstate.authentication.oidc -- Use an OpenId Connect provider for authentication. See [Configuring OpenId Connect](#configuring-openid-connect).
    oidc: {}
    # stackstate.authentication.file -- Configure users, their passwords and roles from (config) file
    file: {}
    # stackstate.authentication.adminPassword -- Password for the 'admin' user that StackState creates by default
    adminPassword:
    # stackstate.authentication.sessionLifetime -- Amount of time to keep a session when a user does not log in
    sessionLifetime: 7d
    # stackstate.authentication.roles -- Extend the default role names in StackState
    roles:
      # stackstate.authentication.roles.admin -- Extend the role names that have admin permissions (default: 'stackstate-admin')
      admin: []
      # stackstate.authentication.roles.platformAdmin -- Extend the role names that have platform admin permissions (default: 'stackstate-platform-admin')
      platformAdmin: []
      # stackstate.authentication.roles.powerUser -- Extend the role names that have power user permissions (default: 'stackstate-power-user')
      powerUser: []
      # stackstate.authentication.roles.guest -- Extend the role names that have guest permissions (default: 'stackstate-guest')
      guest: []
    serviceToken:
      bootstrap:
        # stackstate.authentication.serviceToken.bootstrap.token -- The service token to set as bootstrap token
        token: ""
        # stackstate.authentication.serviceToken.bootstrap.roles -- The roles the service token assumes when its used for authentication
        roles: []
        # stackstate.authentication.serviceToken.bootstrap.ttl -- The amount of time the service token is valid for
        ttl: 24h
  admin:
    authentication:
      # stackstate.admin.authentication.password -- Password used for default platform "admin" api's (low-level tools) of the various services, username: platformadmin
      password:
  # stackstate.java -- Extra Java configuration for StackState
  java:
    # stackstate.java.trustStore -- Java TrustStore (cacerts) file to use
    trustStore:
    # stackstate.java.trustStoreBase64Encoded -- Base64 encoded Java TrustStore (cacerts) file to use. Ignored if stackstate.java.trustStore is set.
    trustStoreBase64Encoded:
    # stackstate.java.trustStorePassword -- Password to access the Java TrustStore (cacerts) file
    trustStorePassword:
  license:
    # stackstate.license.key -- (string) **PROVIDE YOUR LICENSE KEY HERE** The StackState license key needed to start the server.
    key:
  # stackstate.web.baseUrl -- (string) **PROVIDE YOUR BASE URL HERE** Externally visible baseUrl of StackState.
  baseUrl:
  receiver:
    # stackstate.receiver.baseUrl -- (string) **DEPRECATED** Use stackstate.baseUrl instead
    baseUrl:
  experimental:
    server:
      # stackstate.experimental.server.split -- (boolean) Run a single service server or split in multiple sub services as api, state ....
      split: true
  stackpacks:
    # stackstate.stackpacks.installed -- Specify a list of stackpacks to be always installed including their configuration, for an example see [Auto-installing StackPacks](#auto-installing-stackpacks)
    installed: []
##############################
# Dependency chart overrides #
##############################
elasticsearch:
  # elasticsearch.clusterHealthCheckParams -- The Elasticsearch cluster health status params that will be used by readinessProbe command
  clusterHealthCheckParams: "wait_for_status=yellow&timeout=1s"
  # elasticsearch.clusterName -- Name override for Elasticsearch child chart. **Don't change unless otherwise specified; this is a Helm v2 limitation, and will be addressed in a later Helm v3 chart.**
  clusterName: stackstate-elasticsearch
  # elasticsearch.enabled -- Enable / disable chart-based Elasticsearch.
  enabled: true
  # elasticsearch.esJavaOpts -- JVM options
  esJavaOpts: "-Xmx3g -Xms3g -Des.allow_insecure_settings=true"
  # elasticsearch.commonLabels -- Add additional labels to all resources created for elasticsearch
  commonLabels:
    app.kubernetes.io/part-of: stackstate
  # elasticsearch.extraEnvs -- Extra settings that StackState uses for Elasticsearch.
  extraEnvs:
    - name: action.auto_create_index
      value: "true"
    - name: indices.query.bool.max_clause_count
      value: "10000"
  # elasticsearch.minimumMasterNodes -- Minimum number of Elasticsearch master nodes.
  minimumMasterNodes: 2
  nodeGroup: "master"
  # elasticsearch.replicas -- Number of Elasticsearch replicas.
  replicas: 3
  # elasticsearch.resources -- Override Elasticsearch resources
  resources:
    requests:
      cpu: "2000m"
      memory: "4Gi"
      ephemeral-storage: "1Mi"
    limits:
      cpu: "2000m"
      memory: "4Gi"
      ephemeral-storage: "1Gi"
  # elasticsearch.volumeClaimTemplate -- PVC template defaulting to 250Gi default volumes
  volumeClaimTemplate:
    accessModes:
      - "ReadWriteOnce"
    resources:
      requests:
        storage: 250Gi
  prometheus-elasticsearch-exporter:
    enabled: true
    serviceMonitor:
      enabled: false
      # elasticsearch.prometheus-elasticsearch-exporter.serviceMonitor.labels -- Labels for the service monitor
      labels: {}
    podAnnotations:
      ad.stackstate.com/exporter.check_names: '["openmetrics"]'
      ad.stackstate.com/exporter.init_configs: "[{}]"
      ad.stackstate.com/exporter.instances: '[ { "prometheus_url": "http://%%host%%:9108/metrics", "namespace": "stackstate", "metrics": ["elasticsearch_indices_store_*", "elasticsearch_cluster_health_*"] } ]'
    resources:
      limits:
        cpu: "100m"
        memory: "100Mi"
        ephemeral-storage: "1Gi"
      requests:
        cpu: "100m"
        memory: "100Mi"
        ephemeral-storage: "1Mi"
    es:
      uri: http://stackstate-elasticsearch-master:9200
hbase:
  # hbase.enabled -- Enable / disable chart-based HBase.
  enabled: true
  # hbase.commonLabels -- Add additional labels to all resources created for all hbase resources
  commonLabels:
    app.kubernetes.io/part-of: stackstate
  all:
    metrics:
      enabled: true
      # stackstate.components.all.metrics.agentAnnotationsEnabled -- Put annotations on each pod to instruct the stackstate agent to scrape the metrics
      agentAnnotationsEnabled: true
  stackgraph:
    image:
      # hbase.stackgraph.image.tag -- The StackGraph server version, must be compatible with the StackState version
      tag: 4.9.2
  console:
    # hbase.console.enabled -- Enable / disable deployment of the stackgraph-console for debugging.
    enabled: false
    integrity:
      # hbase.console.integrity.enabled -- Enable / disable periodic integrity check to run though a cronjob.
      enabled: false
      # hbase.console.integrity.schedule -- Schedule at which the integrity check runs
      schedule: '*/30 * * * *'
  hbase:
    master:
      # hbase.hbase.master.replicaCount -- Number of HBase master node replicas.
      replicaCount: 2
      resources:
        limits:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1Gi"
          cpu: "50m"
          ephemeral-storage: "1Mi"
    regionserver:
      # hbase.hbase.regionserver.replicaCount -- Number of HBase regionserver node replicas.
      replicaCount: 3
      resources:
        limits:
          memory: "3Gi"
          cpu: "3000m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "3Gi"
          cpu: "1500m"
          ephemeral-storage: "1Mi"
  hdfs:
    # hbase.hdfs.minReplication -- Min number of copies we create from any data block. (If the hbase.hdfs.datanode.replicaCount is set to a lower value than this, we will use the replicaCount instead)
    minReplication: 2
    datanode:
      # hbase.hdfs.datanode.replicaCount -- Number of HDFS datanode replicas.
      replicaCount: 3
      resources:
        limits:
          memory: "4Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "4Gi"
          cpu: "300m"
          ephemeral-storage: "1Mi"
    namenode:
      resources:
        limits:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1Gi"
          cpu: "100m"
          ephemeral-storage: "1Mi"
    secondarynamenode:
      enabled: true
      resources:
        limits:
          memory: "1Gi"
          cpu: "500m"
          ephemeral-storage: "1Gi"
        requests:
          memory: "1Gi"
          cpu: "50m"
          ephemeral-storage: "1Mi"
  tephra:
    # hbase.tephra.replicaCount -- Number of Tephra replicas.
    replicaCount: 2
    resources:
      limits:
        memory: "3Gi"
        cpu: "500m"
        ephemeral-storage: "1Gi"
      requests:
        memory: "2Gi"
        cpu: "250m"
        ephemeral-storage: "1Mi"
  zookeeper:
    # hbase.zookeeper.enabled -- Disable Zookeeper from the HBase chart **Don't change unless otherwise specified**.
    enabled: false
    # hbase.zookeeper.externalServers -- External Zookeeper if not used bundled Zookeeper chart **Don't change unless otherwise specified**.
    externalServers: stackstate-zookeeper-headless
kafkaup-operator:
  enabled: true
  image:
    # kafkaup.image.registry -- Registry containing the image for the KafkaUp operator
    registry: quay.io
    # kafkaup.image.repository -- Repository containing the image for the KafkaUp operator
    repository: stackstate/kafkaup-operator
    # kafkaup.image.tag -- Tag of the image for the KafkaUp operator
    tag: 0.0.2
    # kafkaup.image.pullPolicy -- Pull policy for the image for the KafkaUp operator
    pullPolicy: ""
  kafkaSelectors:
    # kafkaup.kafkaSelectors.statefulSetName -- name of the statefulSet to operate on
    statefulSetName: "stackstate-kafka"
    # kafkaup.kafkaSelectors.podLabel -- pod label of kafka pods to operate on
    podLabel:
      key: "app.kubernetes.io/component"
      value: "kafka"
  # kafkaup.startVersion -- The below version is the version at which we started to use the kafka
  # versioning operator, this should not be changed
  startVersion: "2.3.1"
kafka:
  # kafka.command -- Override kafka container command.
  command:
    - "/scripts/custom-setup.sh"
  externalZookeeper:
    # kafka.externalZookeeper.servers -- External Zookeeper if not used bundled Zookeeper chart **Don't change unless otherwise specified**.
    servers: stackstate-zookeeper-headless
  # kafka.enabled -- Enable / disable chart-based Kafka.
  enabled: true
  podLabels:
    app.kubernetes.io/part-of: stackstate
  volumePermissions:
    enabled: false
  ## kafka.defaultReplicationFactor -- Default replication factors for automatically created topics
  defaultReplicationFactor: 2
  ## kafka.offsetTopicReplicationFactor --  The replication factor for the offsets topic
  offsetsTopicReplicationFactor: 2
  ## kafka.transactionStateLogReplicationFactor -- The replication factor for the transaction topic
  transactionStateLogReplicationFactor: 2
  # kafka.extraDeploy -- Array of extra objects to deploy with the release
  extraDeploy:
    - apiVersion: v1
      kind: ConfigMap
      metadata:
        name: kafka-custom-scripts
      data:
        custom-setup.sh: |-
          #!/bin/bash

          ID="${MY_POD_NAME#"{{ include "common.names.fullname" . }}-"}"

          KAFKA_META_PROPERTIES=/bitnami/kafka/data/meta.properties
          if [[ -f ${KAFKA_META_PROPERTIES} ]]; then
            ID=`grep -e ^broker.id= ${KAFKA_META_PROPERTIES} | sed 's/^broker.id=//'`
            if [[ "${ID}" != "" ]] && [[ "${ID}" -gt 1000 ]]; then
              echo "Using broker ID ${ID} from ${KAFKA_META_PROPERTIES} for compatibility (STAC-9614)"
            fi
          fi

          export KAFKA_CFG_BROKER_ID="$ID"

          exec /entrypoint.sh /run.sh
  # kafka.extraEnvVars -- Extra environment variables to add to kafka pods.
  extraEnvVars:
    - name: KAFKA_CFG_RESERVED_BROKER_MAX_ID
      value: "2000"
    # How long will a producer linger when no data is flowing? We make this quite a high number to make
    # sure that in POC like settings, where there is not always much activity, transactional producer do not get kicked out.
    # See STAC-15583
    # Using MaxInt value, giving 25 days of retention on txIds
    - name: KAFKA_CFG_TRANSACTIONAL_ID_EXPIRATION_MS
      value: "2147483647"
  # kafka.extraVolumes -- Extra volume(s) to add to Kafka statefulset.
  extraVolumes:
    - name: kafka-custom-scripts
      configMap:
        name: kafka-custom-scripts
        defaultMode: 493
  # kafka.extraVolumeMounts -- Extra volumeMount(s) to add to Kafka containers.
  extraVolumeMounts:
    - name: kafka-custom-scripts
      mountPath: /scripts/custom-setup.sh
      subPath: custom-setup.sh
  # kafka.initContainers -- required to make the kafka versionup operator work
  initContainers:
    - name: check-inter-broker-protocol-version
      image: '{{ include "kafka.image" . }}'
      imagePullPolicy: ''
      command:
        - /bin/bash
      args:
        - -c
        - "while [ -z \"${KAFKA_CFG_INTER_BROKER_PROTOCOL_VERSION}\" ]; do echo \"KAFKA_CFG_INTER_BROKER_PROTOCOL_VERSION should be set by operator\"; sleep 1; done"
      resources:
        limits: {}
        requests: {}
  # kafka.fullnameOverride -- Name override for Kafka child chart. **Don't change unless otherwise specified; this is a Helm v2 limitation, and will be addressed in a later Helm v3 chart.**
  fullnameOverride: stackstate-kafka
  image:
    # kafka.image.registry -- Kafka image registry
    registry: quay.io
    # kafka.image.repository -- Kafka image repository
    repository: stackstate/kafka
    # kafka.image.tag -- Kafka image tag. **Since StackState relies on this specific version, it's advised NOT to change this.**
    # When changing this version, be sure to change the pod annotation stackstate.com/kafkaup-operator.kafka_version aswell, in order
    # for the kafkaup operator to upgrade the inter broker protocol version
    tag: 2.8.1-2738720666
  livenessProbe:
    # kafka.livenessProbe.initialDelaySeconds -- Delay before readiness probe is initiated.
    initialDelaySeconds: 240
  # kafka.logRetentionHours -- The minimum age of a log file to be eligible for deletion due to age.
  logRetentionHours: 24
  metrics:
    kafka:
      # kafka.metrics.kafka.enabled -- Whether or not to create a standalone Kafka exporter to expose Kafka metrics.
      enabled: false
    jmx:
      # kafka.metrics.jmx.enabled -- Whether or not to expose JMX metrics to Prometheus.
      enabled: true
      image:
        # kafka.metrics.jmx.image.registry -- Kafka JMX exporter image registry
        registry: quay.io
        # kafka.metrics.jmx.image.repository -- Kafka JMX exporter image repository
        repository: stackstate/jmx-exporter
        # kafka.metrics.jmx.image.tag -- Kafka JMX exporter image tag
        tag: 0.17.0-2738680727
      resources:
        limits:
          cpu: "1"
          memory: "300Mi"
          ephemeral-storage: "1Gi"
        requests:
          cpu: "200m"
          memory: "300Mi"
          ephemeral-storage: "1Mi"
    serviceMonitor:
      # kafka.metrics.serviceMonitor.enabled -- If `true`, creates a Prometheus Operator `ServiceMonitor` (also requires `kafka.metrics.kafka.enabled` or `kafka.metrics.jmx.enabled` to be `true`).
      enabled: false
      # kafka.metrics.serviceMonitor.interval -- How frequently to scrape metrics.
      interval: 20s
      # kafka.metrics.serviceMonitor.labels -- Add extra labels to target a specific prometheus instance
      labels: {}
  readinessProbe:
    # kafka.readinessProbe.initialDelaySeconds -- Delay before readiness probe is initiated.
    initialDelaySeconds: 45
  # kafka.replicaCount -- Number of Kafka replicas.
  replicaCount: 3
  persistence:
    # kafka.persistence.size -- Size of persistent volume for each Kafka pod
    size: 50Gi

  # kafka.commonLabels -- Add additional labels to all resources created for kafka
  commonLabels:
    app.kubernetes.io/part-of: stackstate
  # kafka.podAnnotations -- Kafka Pod annotations.
  podAnnotations:
    ad.stackstate.com/jmx-exporter.check_names: '["openmetrics"]'
    ad.stackstate.com/jmx-exporter.init_configs: "[{}]"
    ad.stackstate.com/jmx-exporter.instances: '[ { "prometheus_url": "http://%%host%%:5556/metrics", "namespace": "stackstate", "metrics": ["*"] } ]'
    # When changing this version, be sure to also change the image, such that the image version and this version are in sync
    stackstate.com/kafkaup-operator.kafka_version: "2.8.1"
  # kafka.resources -- Kafka resources per pods.
  resources:
    limits:
      memory: "2Gi"
      cpu: "1000m"
      ephemeral-storage: "1Gi"
    requests:
      memory: "2Gi"
      cpu: "1000m"
      ephemeral-storage: "1Mi"
  # kafka.zookeeper.enabled -- Disable Zookeeper from the Kafka chart **Don't change unless otherwise specified**.
  zookeeper:
    enabled: false
  topic:
    stsMetricsV2:
      partitionCount: 10
  pdb:
    ## kafka.pdb.create Deploy a pdb object for the Kafka pod
    create: true
    ## kafka.pdb.minAvailable Maximum number/percentage of unavailable Kafka replicas
    minAvailable: ""
    ## kafka.pdb.maxUnavailable Maximum number/percentage of unavailable Kafka replicas
    maxUnavailable: 1
minio:
  # minio.replicas -- Number of MinIO replicas.
  replicas: 1
  persistence:
    # minio.persistence.enabled -- Enables MinIO persistence. Must be enabled when MinIO is not configured as a gateway to AWS S3 or Azure Blob Storage.
    enabled: false
  # minio.fullnameOverride -- **N.B.: Do not change this value!** The fullname override for MinIO subchart is hardcoded so that the stackstate chart can refer to its components.
  fullnameOverride: stackstate-minio
  image:
    # minio.image.registry -- MinIO image registry
    registry: quay.io
    # minio.image.repository -- MinIO image repository
    repository: stackstate/minio
    tag: RELEASE.2021-02-14T04-01-33Z-3118065624
  # minio.accessKey -- Access key for MinIO. Default is set to an invalid value that will cause MinIO to not start up to ensure users of this Helm chart set an explicit value.
  accessKey: setme
  # minio.accessKey -- Secret key for MinIO. Default is set to an invalid value that will cause MinIO to not start up to ensure users of this Helm chart set an explicit value.
  secretKey: setme
  azuregateway:
    # azuregateway.replicas -- Number of azure gateway instances to run in parallel
    replicas: 1
  s3gateway:
    # s3gateway.replicas -- Number of s3 gateway instances to run in parallel
    replicas: 1
zookeeper:
  # zookeeper.enabled -- Enable / disable chart-based Zookeeper.
  enabled: true
  # zookeeper.externalServers -- If `zookeeper.enabled` is set to `false`, use this list of external Zookeeper servers instead.
  externalServers: ""
  # zookeeper.fourlwCommandsWhitelist -- Zookeeper four-letter-word (FLW) commands that are enabled.
  fourlwCommandsWhitelist: "mntr, ruok, stat, srvr"
  # zookeeper.fullnameOverride -- Name override for Zookeeper child chart. **Don't change unless otherwise specified; this is a Helm v2 limitation, and will be addressed in a later Helm v3 chart.**
  fullnameOverride: stackstate-zookeeper
  podLabels:
    app.kubernetes.io/part-of: stackstate
  image:
    # zookeeper.image.registry -- ZooKeeper image registry
    registry: quay.io
    # zookeeper.image.repository -- ZooKeeper image repository
    repository: stackstate/zookeeper
    # zookeeper.image.tag -- ZooKeeper image tag
    tag: 3.6.3-2738717608
  metrics:
    # zookeeper.metrics.enabled -- Enable / disable Zookeeper Prometheus metrics.
    enabled: true
    # zookeeper.metrics.serviceMonitor --
    serviceMonitor:
      # zookeeper.metrics.serviceMonitor.enabled -- Enable creation of `ServiceMonitor` objects for Prometheus operator.
      enabled: false
      # zookeeper.metrics.serviceMonitor.selector -- Default selector to use to target a certain Prometheus instance.
      selector: {}
  resources:
    limits:
      memory: "512Mi"
      cpu: "250m"
      ephemeral-storage: "1Gi"
    requests:
      memory: "512Mi"
      cpu: "100m"
      ephemeral-storage: "1Mi"
  # zookeeper.podAnnotations -- Annotations for ZooKeeper pod.
  podAnnotations:
    ad.stackstate.com/zookeeper.check_names: '["openmetrics"]'
    ad.stackstate.com/zookeeper.init_configs: "[{}]"
    ad.stackstate.com/zookeeper.instances: '[ { "prometheus_url": "http://%%host%%:9141/metrics", "namespace": "stackstate", "metrics": ["*"] } ]'
  # zookeeper.replicaCount -- Default amount of Zookeeper replicas to provision.
  replicaCount: 3
  commonLabels:
    app.kubernetes.io/part-of: stackstate
  pdb:
    ## zookeeper.pdb.create Deploy a pdb object for the Zookeeper pod
    create: true
    ## zookeeper.pdb.minAvailable Maximum number/percentage of unavailable Zookeeper replicas
    minAvailable: ""
    ## zookeeper.pdb.maxUnavailable Maximum number/percentage of unavailable Zookeeper replicas
    maxUnavailable: 1
anomaly-detection:
  # anomaly-detection.enabled -- Enables anomaly detection chart
  enabled: true
  cpu:
    # anomaly-detection.cpu.limit -- CPU resource limit
    limit: "2000m"
    # anomaly-detection.cpu.request -- CPU resource request
    request: "1000m"
  memory:
    # anomaly-detection.memory.limit -- Memory resource limit
    limit: "3Gi"
    # anomaly-detection.memory.request -- Memory resource request
    request: "3Gi"
  pdb:
    # anomaly-detection.pdb.maxUnavailable -- Maximum number of pods that can be unavailable for the anomaly detection
    maxUnavailable: 0
  image:
    # anomaly-detection.image.imagePullPolicy -- The default pullPolicy used for anomaly detection pods.
    imagePullPolicy: IfNotPresent
    # 'tag' is commented here since we take the latest image tag compatible with stackstate chart from anomaly-detection sub-chart
    # It is still possible to override it here.
    # anomaly-detection.image.tag -- the chart image tag, e.g. 4.1.3-latest
    # tag:

    # anomaly-detection.image.pullSecretName -- Name of ImagePullSecret to use for all pods.
    pullSecretName:
    # anomaly-detection.image.pullSecretUsername -- Username used to login to the registry to pull Docker images of all pods.
    pullSecretUsername:
    # anomaly-detection.image.pullSecretUsername -- Password used to login to the registry to pull Docker images of all pods.
    pullSecretPassword:
    # anomaly-detection.image.registry -- Base container image registry for all containers, except for the wait container
    registry: quay.io
    # anomaly-detection.image.spotlightRepository -- Repository of the spotlight Docker image.
    spotlightRepository: stackstate/spotlight
  stackstate:
    # anomaly-detection.stackstate.instance -- **Required Stackstate instance URL, e.g http://stackstate-router:8080
    instance: 'http://{{ include "stackstate.hostname.prefix" . }}-router:8080'
    # anomaly-detection.stackstate.authType -- Type of authentication. There are three options 1) "token" - with service account token (default), 2) "api-token" - with Stackstate API Token, 3) "cookie" - username, password based auth.
    authType: token
    # anomaly-detection.stackstate.username -- Stackstate Username used by spotlight for authentication, it is expected to be set only in case if authType = "cookie"
    username:
    # anomaly-detection.stackstate.password -- Stackstate Password used by spotlight for authentication, it is expected to be set only in case if authType = "cookie"
    password:
    # anomaly-detection.stackstate.apiToken -- Stackstate Api token that used by spotlight for authentication, it is expected to be set only in case if authType = "api-token"
    apiToken:
  # anomaly-detection.threadWorkers -- The number of worker threads.
  threadWorkers: 3
  # anomaly-detection.ingress -- Status interface ingress
  ingress:
    # anomaly-detection.ingress.enabled -- Enables ingress controller for status interface
    enabled: false
    # anomaly-detection.ingress.hostname -- Status interface hostname e.g. spotlight.local.domain
    hostname:
    # anomaly-detection.ingress.port - Status Interface port
    port: 8090
    # anomaly-detection.ingress.annotations - Annotations for ingress objects.
    annotations: {}
    # e.g.
    #     kubernetes.io/ingress.class: nginx
    #     cert-manager.io/cluster-issuer: letsencrypt-prod
    #     external-dns.alpha.kubernetes.io/hostname: spotlight.local.domain
    #     nginx.ingress.kubernetes.io/ingress.class: nginx
    #     nginx.ingress.kubernetes.io/proxy-body-size: 100m
    #     nginx.ingress.kubernetes.io/rewrite-target: "/$1"
    # anomaly-detection.ingress.hosts - List of ingress hostnames
    hosts: []
    # - host: spotlight.local.domain

    # anomaly-detection.ingress.tls - List of ingress TLS certificates to use.
    tls:
    # - hosts:
    #     - spotlight.local.domain
stackstate-agent:
  # stackstate-agent.enabled -- Deploy the StackState Kubernetes Agent so StackState can monitor the cluster it runs in
  enabled: false
  stackstate:
    cluster:
      # stackstate.cluster.name -- (string) **PROVIDE KUBERNETES CLUSTER NAME HERE** Name of the Kubernetes cluster where the agent will be installed.
      name:
      # stackstate.cluster.authToken -- Provide a token to enable secure communication between the agent and the cluster agent.
      authToken:
    # stackstate.url -- (string) **PROVIDE STACKSTATE URL HERE** URL of the StackState installation to receive data from the agent.
    url: 'http://{{ include "stackstate.hostname.prefix" . }}-router:8080/receiver/stsAgent'
cluster-role:
  # cluster-role.enabled -- Deploy the ClusterRole(s) and ClusterRoleBinding(s) together with the chart. Can be disabled if these need to be installed by an administrator of the Kubernetes cluster.
  enabled: true
pull-secret:
  # pull-secret.enabled -- Deploy the ImagePullSecret for the chart.
  enabled: false
  # pull-secret.fullNameOverride -- Name of the ImagePullSecret that will be created. This can be referenced by setting the `global.imagePullSecrets[0].name` value in the chart.
  fullNameOverride: ''
  # pull-secret.credentials -- Registry and assotiated credentials (username, password) that will be stored in the pull-secret
  credentials: []
